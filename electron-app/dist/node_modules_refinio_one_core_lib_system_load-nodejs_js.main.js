"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "node_modules_refinio_one_core_lib_system_load-nodejs_js";
exports.ids = ["node_modules_refinio_one_core_lib_system_load-nodejs_js"];
exports.modules = {

/***/ "../node_modules/@refinio/one.core/lib/system/fetch-file.js":
/*!******************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/fetch-file.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchFile: () => (/* binding */ fetchFile),\n/* harmony export */   setPlatformForFf: () => (/* binding */ setPlatformForFf)\n/* harmony export */ });\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ \"../node_modules/@refinio/one.core/lib/system/platform.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2023\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n\nlet FF;\nfunction setPlatformForFf(exports) {\n    FF = exports;\n}\n/**\n * Fetch a file from remote location via HTTPRequest (GET)\n * @param {string} url - A URL to a remote location. If relative, it is relative to the loaded\n * app if this is called from a browser.\n * @returns {Promise<string>}\n */\nfunction fetchFile(url) {\n    (0,_platform_js__WEBPACK_IMPORTED_MODULE_0__.ensurePlatformLoaded)();\n    return FF.fetchFile(url);\n}\n//# sourceMappingURL=fetch-file.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/fetch-file.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/load-nodejs.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/load-nodejs.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _crypto_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto-helpers.js */ \"../node_modules/@refinio/one.core/lib/system/crypto-helpers.js\");\n/* harmony import */ var _crypto_scrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crypto-scrypt.js */ \"../node_modules/@refinio/one.core/lib/system/crypto-scrypt.js\");\n/* harmony import */ var _fetch_file_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch-file.js */ \"../node_modules/@refinio/one.core/lib/system/fetch-file.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./platform.js */ \"../node_modules/@refinio/one.core/lib/system/platform.js\");\n/* harmony import */ var _post_json_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./post-json.js */ \"../node_modules/@refinio/one.core/lib/system/post-json.js\");\n/* harmony import */ var _settings_store_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./settings-store.js */ \"../node_modules/@refinio/one.core/lib/system/settings-store.js\");\n/* harmony import */ var _storage_base_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./storage-base.js */ \"../node_modules/@refinio/one.core/lib/system/storage-base.js\");\n/* harmony import */ var _storage_base_delete_file_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./storage-base-delete-file.js */ \"../node_modules/@refinio/one.core/lib/system/storage-base-delete-file.js\");\n/* harmony import */ var _storage_streams_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./storage-streams.js */ \"../node_modules/@refinio/one.core/lib/system/storage-streams.js\");\n/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./websocket.js */ \"../node_modules/@refinio/one.core/lib/system/websocket.js\");\n/* harmony import */ var _nodejs_crypto_helpers_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./nodejs/crypto-helpers.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/crypto-helpers.js\");\n/* harmony import */ var _nodejs_crypto_scrypt_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodejs/crypto-scrypt.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/crypto-scrypt.js\");\n/* harmony import */ var _nodejs_fetch_file_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./nodejs/fetch-file.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/fetch-file.js\");\n/* harmony import */ var _nodejs_post_json_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodejs/post-json.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/post-json.js\");\n/* harmony import */ var _nodejs_settings_store_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./nodejs/settings-store.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/settings-store.js\");\n/* harmony import */ var _nodejs_storage_base_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./nodejs/storage-base.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/storage-base.js\");\n/* harmony import */ var _nodejs_storage_base_delete_file_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./nodejs/storage-base-delete-file.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/storage-base-delete-file.js\");\n/* harmony import */ var _nodejs_storage_streams_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./nodejs/storage-streams.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/storage-streams.js\");\n/* harmony import */ var _nodejs_websocket_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./nodejs/websocket.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/websocket.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2023\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @module\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(0,_crypto_helpers_js__WEBPACK_IMPORTED_MODULE_0__.setPlatformForCh)(_nodejs_crypto_helpers_js__WEBPACK_IMPORTED_MODULE_10__);\n(0,_crypto_scrypt_js__WEBPACK_IMPORTED_MODULE_1__.setPlatformForCs)(_nodejs_crypto_scrypt_js__WEBPACK_IMPORTED_MODULE_11__);\n(0,_fetch_file_js__WEBPACK_IMPORTED_MODULE_2__.setPlatformForFf)(_nodejs_fetch_file_js__WEBPACK_IMPORTED_MODULE_12__);\n(0,_post_json_js__WEBPACK_IMPORTED_MODULE_4__.setPlatformForPj)(_nodejs_post_json_js__WEBPACK_IMPORTED_MODULE_13__);\n(0,_settings_store_js__WEBPACK_IMPORTED_MODULE_5__.setPlatformForSs)(_nodejs_settings_store_js__WEBPACK_IMPORTED_MODULE_14__);\n(0,_storage_base_js__WEBPACK_IMPORTED_MODULE_6__.setPlatformForSb)(_nodejs_storage_base_js__WEBPACK_IMPORTED_MODULE_15__);\n(0,_storage_base_delete_file_js__WEBPACK_IMPORTED_MODULE_7__.setPlatformForSbdf)(_nodejs_storage_base_delete_file_js__WEBPACK_IMPORTED_MODULE_16__);\n(0,_storage_streams_js__WEBPACK_IMPORTED_MODULE_8__.setPlatformForSst)(_nodejs_storage_streams_js__WEBPACK_IMPORTED_MODULE_17__);\n(0,_websocket_js__WEBPACK_IMPORTED_MODULE_9__.setPlatformForWs)(_nodejs_websocket_js__WEBPACK_IMPORTED_MODULE_18__);\n(0,_platform_js__WEBPACK_IMPORTED_MODULE_3__.setPlatformLoaded)('nodejs');\n//# sourceMappingURL=load-nodejs.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/load-nodejs.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/crypto-helpers.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/crypto-helpers.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCryptoHash: () => (/* binding */ createCryptoHash),\n/* harmony export */   createRandomSHA256Hash: () => (/* binding */ createRandomSHA256Hash),\n/* harmony export */   createRandomString: () => (/* binding */ createRandomString)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2017\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @private\n * @module\n */\n/*\n * NOTE ABOUT ERRORS AND PROMISE STYLE (promise.catch instead of try/catch)\n *\n * We cannot use \"new Promise\" and reject or throw in there - in our experiments this did not\n * result in an async. stack trace. The node.js function must already be the promisified version\n * to begin with.\n *\n * Unlike \"fs\" methods the error thrown e.g. from randomBytes (promisified version!) did indeed\n * include a stack trace in our tests.\n * Follow https://bugs.chromium.org/p/v8/issues/detail?id=9443\n */\n\n\n\nconst randomBytesPromisified = (0,util__WEBPACK_IMPORTED_MODULE_1__.promisify)(crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes);\n/**\n * Helper function to have one place where the crypto hash of a UTF-8 string is calculated. The\n * implementation depends on the platform. This function is asynchronous because the hash\n * function of the crypto API implemented in browsers is asynchronous.\n * @internal\n * @static\n * @param {string} s - The input string\n * @returns {Promise<SHA256Hash>} Returns a promise that resolves with the SHA-256 hash over the\n * input string\n */\nfunction createCryptoHash(s) {\n    return Promise.resolve((0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)('sha256').update(s, 'utf8').digest('hex'));\n}\n/**\n * Helper function that creates a *secure* random string characters.\n *\n * It uses crypto-functions of the respective platform to create a *secure* random string.\n *\n * node.js: crypto.randomBytes()\n * low.js: crypto.randomBytes() (low.js implementation)\n * moddable: NOT SECURE: There is no native method, so we use Math.random()\n * browser: crypto.getRandomValues()\n * rn: package LinusU/react-native-get-random-values, i.e.\n *     - iOS: secrandomcopybytes()\n *       https://developer.apple.com/documentation/security/1399291-secrandomcopybytes\n *     - Android: class SecureRandom\n *       https://developer.android.com/reference/java/security/SecureRandom\n *\n * Different platforms set different limits for our implementation, which, for portability, we\n * enforce on all platforms:\n *\n * - Maximum string length of 65,536 characters\n * - Returns a promise because on node.js the (preferred way to call the native) method is\n *   asynchronous\n *\n * @internal\n * @static\n * @param {number} [length=64] - Desired length of the random string. The maximum allowed is\n * 65,536 (platform limit in browsers, enforced on all our platforms for portability).\n * @param {boolean} [hex=false] - If true the random string will only contain characters\n * `0123456789abcdef` (hexadecimal, lowercase). If false the string will contain characters from\n * the set `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-`\n * @returns {Promise<string>} A random string\n */\nasync function createRandomString(length = 64, hex = false) {\n    // The size limitation exists on some supported platforms, so we enforce it on all.\n    if (length > 65536) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('CR-RS1', { length });\n    }\n    return await randomBytesPromisified(length).then(buf => {\n        // Chars needs to contain 2^n elements with n <= 8 to get an even distribution\n        // of characters.\n        // THESE ARE 64 CHARACTERS (\"magic number\" constant used as index below)\n        // THE FIRST 16 ARE HEX CHARACTERS\n        const CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\n        // For a hexadecimal string all we have to do is to only use the first 16 characters.\n        const n = hex ? 16 : 64;\n        for (const [i, v] of buf.entries()) {\n            buf[i] = CHARS.charCodeAt(v % n);\n        }\n        return buf.toString('utf8');\n    });\n}\n/**\n * This function is a frontend for `createRandomString` to correctly type-annotate the special case\n * when a random hex string of exactly 64 characters is created: The result will then be a\n * SHA-256 hash.\n * @internal\n * @returns {Promise<SHA256Hash>}\n */\nfunction createRandomSHA256Hash() {\n    return createRandomString(64, true);\n}\n//# sourceMappingURL=crypto-helpers.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/crypto-helpers.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/crypto-scrypt.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/crypto-scrypt.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deriveBinaryKey: () => (/* binding */ deriveBinaryKey),\n/* harmony export */   scrypt: () => (/* binding */ scrypt)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/* harmony import */ var _util_buffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/buffer.js */ \"../node_modules/@refinio/one.core/lib/util/buffer.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2017\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @private\n * @module\n */\n\n\n\n\n/**\n * On node.js this is the promisified version of that platforms crypto module's asynchronous\n * \"scrypt\" key derivation function (KDF).\n * @internal\n * @static\n * @param {Uint8Array | ArrayBufferLike} password\n * @param {Uint8Array | ArrayBufferLike} salt\n * @param {number} N\n * @param {number} r\n * @param {number} p\n * @param {number} [dkLen=32]\n * @returns {Promise<Uint8Array>}\n */\nfunction scrypt(password, salt, N = 1024, r = 8, p = 1, dkLen = 32) {\n    return new Promise((resolve, reject) => {\n        (0,crypto__WEBPACK_IMPORTED_MODULE_0__.scrypt)((0,_util_buffer_js__WEBPACK_IMPORTED_MODULE_3__.getUint8Array)(password), (0,_util_buffer_js__WEBPACK_IMPORTED_MODULE_3__.getUint8Array)(salt), dkLen, { N, r, p }, (err, derivedKey) => {\n            if (err) {\n                return reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('CRS-SCR1', err));\n            }\n            resolve(new Uint8Array(\n            // Copy to be on the safe side: Because this is small it comes from a much\n            // larger shared buffer. That is why offset and length are necessary too!\n            derivedKey.buffer.slice(derivedKey.byteOffset, derivedKey.byteOffset + derivedKey.byteLength)));\n        });\n    });\n}\n/**\n * @internal\n * @static\n * @param {string} secret - The string will be\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize|normalized}.\n * @param {Uint8Array | ArrayBufferLike} salt\n * @param {number} [len=32]\n * @returns {Promise<Uint8Array>}\n */\nasync function deriveBinaryKey(secret, salt, len = 32) {\n    const encoder = new util__WEBPACK_IMPORTED_MODULE_1__.TextEncoder();\n    return await scrypt(encoder.encode(secret.normalize('NFKC')), (0,_util_buffer_js__WEBPACK_IMPORTED_MODULE_3__.getUint8Array)(salt), 1024, 8, 1, len);\n}\n//# sourceMappingURL=crypto-scrypt.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/crypto-scrypt.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/fetch-file.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/fetch-file.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchFile: () => (/* binding */ fetchFile)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2023\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @module\n */\n\n\n\n/**\n * Read file from remote location via `http(s).request` (GET)\n * @internal\n * @param {string} url - A URL to a remote location.\n * @returns {Promise<string>}\n */\nasync function fetchFile(url) {\n    const { protocol, hostname, port, pathname } = new URL(url);\n    if (protocol !== 'https:' && protocol !== 'http:') {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('FF-FF1', { protocol, url });\n    }\n    return new Promise((resolve, reject) => {\n        const options = {\n            hostname: hostname,\n            port: port,\n            path: pathname,\n            method: 'GET'\n        };\n        const request = protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_1__.request : http__WEBPACK_IMPORTED_MODULE_0__.request;\n        const req = request(options, async (res) => {\n            let data = '';\n            for await (const chunk of res) {\n                data += chunk;\n            }\n            if (res.statusCode === 200) {\n                resolve(data);\n            }\n            else {\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('FF-FF2', { code: res.statusCode, text: data }));\n            }\n        });\n        req.on('error', (error) => {\n            reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('FF-FF3', error));\n        });\n        req.end();\n    });\n}\n//# sourceMappingURL=fetch-file.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/fetch-file.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/post-json.js":
/*!************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/post-json.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   postJson: () => (/* binding */ postJson)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2023\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @module\n */\n\n\n\n/**\n * Post json to a remote location via `http(s).request` (POST)\n * @internal\n * @param {string} url - A URL to a remote location.\n * @param {string} jsonContent - Already stringified JSON\n * @returns {Promise<void>}\n */\nasync function postJson(url, jsonContent) {\n    const { protocol, hostname, port, pathname } = new URL(url);\n    if (protocol !== 'https:' && protocol !== 'http:') {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('PJ-PJ1', { protocol, url });\n    }\n    const request = protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_1__.request : http__WEBPACK_IMPORTED_MODULE_0__.request;\n    await new Promise((resolve, reject) => {\n        const options = {\n            hostname: hostname,\n            port: port,\n            path: pathname,\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        };\n        const req = request(options, async (res) => {\n            let data = '';\n            for await (const chunk of res) {\n                data += chunk;\n            }\n            // Only checking code 200 and 201 should be okay for POST\n            // https://stackoverflow.com/a/69952759/544779\n            if (res.statusCode === 200 || res.statusCode === 201) {\n                resolve();\n            }\n            else {\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('PJ-PJ2', { code: res.statusCode, text: data }));\n            }\n        });\n        req.on('error', (error) => {\n            reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('PJ-PJ3', error));\n        });\n        req.write(jsonContent);\n        req.end();\n    });\n}\n//# sourceMappingURL=post-json.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/post-json.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/settings-store.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/settings-store.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SettingsStore: () => (/* binding */ SettingsStore)\n/* harmony export */ });\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/* harmony import */ var _util_sorted_stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/sorted-stringify.js */ \"../node_modules/@refinio/one.core/lib/util/sorted-stringify.js\");\n/* harmony import */ var _storage_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../storage-base.js */ \"../node_modules/@refinio/one.core/lib/system/storage-base.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2021\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * The settings store is a key-value store used to store instance settings that cannot or should\n * not be stored in the usual ONE storage places.\n * The node.js version stores a file with the settings ina JSON.stringified object in the\n * \"private\" storage space.\n * @private\n * @module\n */\n\n\n\n\n\nconst SETTINGS_FILE = 'SettingsStore';\n/**\n * Retrieves all the Store entries.\n *\n * It is an error (`SB-INIT1`) if the storage has not yet been initialized, since we may be\n * missing an actually existing SettingsStore file.\n *\n * it is **not** an error if that file does not exist.\n * @returns {Promise<AnyObject>}\n */\nasync function readSettings() {\n    const content = await (0,fs_promises__WEBPACK_IMPORTED_MODULE_0__.readFile)((0,path__WEBPACK_IMPORTED_MODULE_1__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_4__.getBaseDirOrName)(), SETTINGS_FILE), 'utf8').catch((err) => {\n        if (err.code === 'ENOENT') {\n            return '{}';\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SET-READ', err);\n    });\n    return JSON.parse(content);\n}\n/**\n * Retrieves SettingsStore item by key.\n * @param {string} key\n * @returns {Promise<string|undefined>}\n */\nasync function getItem(key) {\n    try {\n        const entries = await readSettings();\n        return entries[key];\n    }\n    catch (error) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SET-GET', { reason: error.message });\n    }\n}\n// \"setItem\" and \"removeItem\" read, then modify, then save the file. This must be locked or two\n// simultaneous operations could lead to an operation getting overwritten.\n// DESIGN DECISION: We report an error instead of trying to serialize writes. This is a very\n// rare niche operation and callers should just make sure that there never is more than one in\n// progress.\nlet G_LOCK = false;\n/**\n * Sets Store item by key & value.\n * @param {string} key\n * @param {string} value\n */\nasync function setItem(key, value) {\n    if (G_LOCK) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SET-LOCK1', { key });\n    }\n    G_LOCK = true;\n    try {\n        const entries = await readSettings();\n        entries[key] = value;\n        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_0__.writeFile)((0,path__WEBPACK_IMPORTED_MODULE_1__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_4__.getBaseDirOrName)(), SETTINGS_FILE), (0,_util_sorted_stringify_js__WEBPACK_IMPORTED_MODULE_3__.stringify)(entries), {\n            flag: 'w'\n        });\n    }\n    catch (error) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SET-SET', { reason: error.message });\n    }\n    finally {\n        G_LOCK = false;\n    }\n}\n/**\n * Removes Store's entry by the given key.\n * @param {string} key\n */\nasync function removeItem(key) {\n    if (G_LOCK) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SET-LOCK1', { key });\n    }\n    G_LOCK = true;\n    try {\n        const entries = await readSettings();\n        delete entries[key];\n        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_0__.writeFile)((0,path__WEBPACK_IMPORTED_MODULE_1__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_4__.getBaseDirOrName)(), SETTINGS_FILE), (0,_util_sorted_stringify_js__WEBPACK_IMPORTED_MODULE_3__.stringify)(entries), {\n            flag: 'w'\n        });\n    }\n    catch (error) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SET-RMV', { reason: error.message });\n    }\n    finally {\n        G_LOCK = false;\n    }\n}\n/**\n * Removes the Settings Store file entirely.\n */\nasync function clear() {\n    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_0__.unlink)((0,path__WEBPACK_IMPORTED_MODULE_1__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_4__.getBaseDirOrName)(), SETTINGS_FILE)).catch((err) => {\n        if (err.code !== 'ENOENT') {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SET-CLR', err);\n        }\n    });\n}\n/**\n * Settings storage for {@link PLATFORMS.NODE_JS}\n * @internal\n */\nconst SettingsStore = {\n    getItem,\n    setItem,\n    removeItem,\n    clear\n};\n//# sourceMappingURL=settings-store.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/settings-store.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/storage-base-delete-file.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/storage-base-delete-file.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteFile: () => (/* binding */ deleteFile)\n/* harmony export */ });\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/* harmony import */ var _storage_base_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../storage-base-common.js */ \"../node_modules/@refinio/one.core/lib/storage-base-common.js\");\n/* harmony import */ var _storage_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage-base.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/storage-base.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2017\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * The delete function is in its own module to underline the exceptional nature of removing\n * files from ONE.\n * @private\n * @module\n */\n/*\n * NOTE ABOUT ERRORS AND PROMISE STYLE (promise.catch instead of try/catch)\n *\n * Low-level functions for file-access don't throw standard Javascript errors, they throw\n * node.js SYSTEM errors. Ref.: https://nodejs.org/api/errors.html#errors_system_errors\n *\n * When calling node.js fs methods we use .catch() instead of try/catch because\n *\n * 1. Only the former manages to enable async. stack trace creation (a feature available in\n *    recent node.js/V8)\n * 2. We also need to throw a createError(err) to get the stack trace. The one we get from node.js\n *    does not have it. Our createError() method always creates a createError.\n */\n\n\n\n\n\n/**\n * This method removes a file from storage. If the file does not exist, nothing happens, no error\n * is thrown.\n * @internal\n * @static\n * @param {string} filename - The name of the file to be deleted\n * @param {StorageDirTypes} [type='objects']\n * @returns {Promise<undefined>} Returns a promise that resolves with `undefined`.\n * @throws {Error} Throws an `Error` if no filename is given\n */\nasync function deleteFile(filename, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_3__.STORAGE.OBJECTS) {\n    if (filename === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SBD-DEL1', { type });\n    }\n    const fileWithPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_4__.getStorageDirForFileType)(type), filename);\n    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_0__.unlink)(fileWithPath).catch((err) => {\n        if (err.code !== 'ENOENT') {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SBD-DEL2', err);\n        }\n    });\n}\n//# sourceMappingURL=storage-base-delete-file.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/storage-base-delete-file.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/storage-base.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/storage-base.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendUTF8SystemMapFile: () => (/* binding */ appendUTF8SystemMapFile),\n/* harmony export */   changeStoragePassword: () => (/* binding */ changeStoragePassword),\n/* harmony export */   closeStorage: () => (/* binding */ closeStorage),\n/* harmony export */   deleteStorage: () => (/* binding */ deleteStorage),\n/* harmony export */   doesStorageExist: () => (/* binding */ doesStorageExist),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   fileSize: () => (/* binding */ fileSize),\n/* harmony export */   getFileType: () => (/* binding */ getFileType),\n/* harmony export */   getStorageDirForFileType: () => (/* binding */ getStorageDirForFileType),\n/* harmony export */   initStorage: () => (/* binding */ initStorage),\n/* harmony export */   listAllIdHashes: () => (/* binding */ listAllIdHashes),\n/* harmony export */   listAllObjectHashes: () => (/* binding */ listAllObjectHashes),\n/* harmony export */   listAllReverseMapNames: () => (/* binding */ listAllReverseMapNames),\n/* harmony export */   normalizeFilename: () => (/* binding */ normalizeFilename),\n/* harmony export */   readPrivateBinaryRaw: () => (/* binding */ readPrivateBinaryRaw),\n/* harmony export */   readTextFileSection: () => (/* binding */ readTextFileSection),\n/* harmony export */   readUTF8TextFile: () => (/* binding */ readUTF8TextFile),\n/* harmony export */   writePrivateBinaryRaw: () => (/* binding */ writePrivateBinaryRaw),\n/* harmony export */   writeUTF8SystemMapFile: () => (/* binding */ writeUTF8SystemMapFile),\n/* harmony export */   writeUTF8TextFile: () => (/* binding */ writeUTF8TextFile)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/* harmony import */ var _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../storage-base-common.js */ \"../node_modules/@refinio/one.core/lib/storage-base-common.js\");\n/* harmony import */ var _util_function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/function.js */ \"../node_modules/@refinio/one.core/lib/util/function.js\");\n/* harmony import */ var _util_object_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/object.js */ \"../node_modules/@refinio/one.core/lib/util/object.js\");\n/* harmony import */ var _util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/type-checks-basic.js */ \"../node_modules/@refinio/one.core/lib/util/type-checks-basic.js\");\n/* harmony import */ var _util_type_checks_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/type-checks.js */ \"../node_modules/@refinio/one.core/lib/util/type-checks.js\");\n/* harmony import */ var _storage_base_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../storage-base.js */ \"../node_modules/@refinio/one.core/lib/system/storage-base.js\");\n/* harmony import */ var _util_buffer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/buffer.js */ \"../node_modules/@refinio/one.core/lib/util/buffer.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2018\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @private\n * @module\n */\n/*\n * NOTE ABOUT ERRORS AND PROMISE STYLE (promise.catch instead of try/catch)\n *\n * Low-level functions for file-access don't throw standard Javascript errors, they throw\n * node.js SYSTEM errors. Ref.: https://nodejs.org/api/errors.html#errors_system_errors\n *\n * When calling node.js fs methods we use .catch() instead of try/catch because\n *\n * 1. Only the former manages to enable async. stack trace creation (a feature available in\n *    recent node.js/V8)\n * 2. We also need to throw a createError(err) to get the stack trace. The one we get from node.js\n *    does not have it. Our createError() method always creates a createError.\n *\n * Follow https://bugs.chromium.org/p/v8/issues/detail?id=9443\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst { F_OK, O_APPEND, O_CREAT, O_WRONLY } = fs__WEBPACK_IMPORTED_MODULE_1__.constants;\n/**\n * Points to the subdirectories used to store data. The initStorage() method sets the concrete\n * values and prepends the parent directory received from the outside.\n * ```\n *   objects: '',\n *   tmp: '',\n *   rmaps: '',\n *   vheads: '',\n *   acache: '',\n *   private: ''\n * ```\n * @private\n * @type {object}\n */\nconst STORAGE_DIRS = Object.values(_storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE).reduce((accumulator, type) => {\n    accumulator[type] = '';\n    return accumulator;\n}, {});\n/**\n * This is a somewhat arbitrary cutoff for the number of hash characters used to locate a\n * subdirectory for the given object file. The absolute maximum of course would be 64,\n * which would give every single file its own directory. Since we pre-create all subdirectories\n * and since having too many subdirectories with too few file in them makes no practical sense\n * we place a practical limit. Note that since the first `SUB_DIR_LVL` characters of each SHA-256\n * hex hash string are used to locate the subdirectory the number of subdirectories is\n * 16**SUB_DIR_LVL. If the first 4 characters are used that will be 65,536 subdirectories. ANy\n * value higher than that - the next one being 1,048,576 - is too much for all practical purposes.\n * @see SUB_DIR_LVL\n * @private\n * @type {number}\n */\nconst MAX_LEVELS = 4;\n/**\n * This variable is set to the value of the initInstance() option property `nHashCharsForSubDirs`\n * to remember it for this session.\n * In \"object\" storage, the first `n` characters of o files name - a hexadecimal SHA-256 hash\n * string - are used to locate the file in a subdirectory of that name. For example, if a file\n * name (hash) starts with \"0fe123....\" and n=2, then the file will be located not in directory\n * `objects/` but in directory `objects/0f/`. This hierarchical storage option is only offered on\n * *some* platforms.\n * @see MAX_LEVELS\n * @private\n * @type {number}\n */\nlet SUB_DIR_LVL = 0;\n/**\n * @internal\n * @static\n * @param {StorageDirTypes} type\n * @returns {string} Returns the storage directory for the given storage type\n * @throws {Error} Throws an error if the database has not yet been initialized\n */\nfunction getStorageDirForFileType(type) {\n    if (STORAGE_DIRS.objects === '') {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-NO-INIT2');\n    }\n    return STORAGE_DIRS[type];\n}\n/**\n * @private\n * @param {string} file - The file or directory with the full path or a path relative to\n * whatever the current base directory is.\n * @returns {Promise<boolean>}\n */\nasync function fileExists(file) {\n    // See the note at the top about the use of .catch()\n    return await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.access)(file, F_OK)\n        .then(() => true)\n        .catch((err) => {\n        if (err.code === 'ENOENT') {\n            return false;\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-EXISTS', err);\n    });\n}\n/**\n * USES MODULE-LEVEL VARIABLE `STORAGE_DIRS` (because all functions do anyway and are impure)\n * @private\n * @param {number} levels - The number from instanceInit property `nHashCharsForSubDirs` (see there)\n * @returns {Promise<undefined>}\n */\nasync function createStorageDirs(levels) {\n    await Promise.all(Object.values(STORAGE_DIRS).map(dir => \n    // See the note at the top about the use of .catch()\n    (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.mkdir)(dir, { recursive: true }).catch((err) => {\n        if (err.code !== 'EEXIST') {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-MKDIRS', err);\n        }\n    })));\n    // On Windows only the write-permission can be changed, and the distinction among the\n    // permissions of group, owner or others is not implemented.\n    // https://nodejs.org/dist/latest-v12.x/docs/api/fs.html#fs_file_modes\n    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.chmod)(STORAGE_DIRS.private, 0o700);\n    // From here on it's only about the \"objects\" directory\n    if (levels === 0) {\n        return;\n    }\n    if (levels > MAX_LEVELS || levels < 0) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-CRLVL1', { max: MAX_LEVELS, val: levels });\n    }\n    SUB_DIR_LVL = levels;\n    for (let i = 0; i < 16 ** levels; i++) {\n        // eslint-disable-next-line no-await-in-loop\n        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.mkdir)((0,path__WEBPACK_IMPORTED_MODULE_3__.join)(STORAGE_DIRS.objects, i.toString(16).padStart(levels, '0')));\n    }\n}\n/**\n * This function is necessary because \"objects\" storage can be configured to have a variable\n * number of subdirectories to store hash-named object files in based on the first n characters\n * of their hash (name). If this feature is not used then the path to the file is more simple.\n * @internal\n * @static\n * @async\n * @param {string} filename\n * @param {StorageDirTypes} [type='objects']\n * @returns {string}\n */\nfunction normalizeFilename(filename, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if (STORAGE_DIRS.objects === '') {\n        // Storage has not been initialized, so we don't have a directory\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-NORM-FN1');\n    }\n    return type === _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS && SUB_DIR_LVL > 0\n        ? (0,path__WEBPACK_IMPORTED_MODULE_3__.join)(STORAGE_DIRS[type], filename.substring(0, SUB_DIR_LVL), filename)\n        : (0,path__WEBPACK_IMPORTED_MODULE_3__.join)(STORAGE_DIRS[type], filename);\n}\n/**\n * The node.js specific storage initialization involves creation of the given directory if it\n * does not exist yet (but this is not recursive so the parent directory has to already exist).\n *\n * **Note:**\n * The `directory` parameter is declared as \"optional\" even though it is not because this\n * platform-specific implementation of this method is only one implementation and others don't\n * require a parameter. An application using ONE with types might get errors depending on\n * which platform specific version is in `lib/system/` so we need to keep the APIs of the\n * different platform files synchronized. That means no static typing, but there is a runtime\n * check anyway.\n * @internal\n * @static\n * @async\n * @param {object} options\n * @param {SHA256IdHash} options.instanceIdHash\n * @param {boolean} [options.wipeStorage=false] - If `true` **all files in storage will be\n * deleted** when the instance is initialized. All files means *every single file*. Storage is\n * wiped clean.\n * @param {string} [options.name] - Platform dependent optional identifier of the storage location.\n * One platform where the file system is used, such as node.js, this is a directory. In browsers\n * this is the name component of the IndexedDB database (the other component is the instance ID\n * hash).\n * If this is a directory, **independent of the platform always use \"/\" as path component\n * separator here.** *(We have to be flexible handling paths we get from the system, but we have\n * to standardize the paths we use in our cross-platform code.)*\n * @param {number} [options.nHashCharsForSubDirs=0] - In \"object\" storage, the first `n`\n * characters of o files name - a hexadecimal SHA-256 hash string - are used to locate the file in\n * a subdirectory of that name. For example, if a file name (hash) starts with \"0fe123....\" and\n * n=2, then the file will be located not in directory `objects/` but in directory\n * `objects/0f/`. This hierarchical storage option is only offered on *some* platforms. When\n * this option has a number higher than 0 on a platform that does not support it an error is thrown.\n * @param {boolean} [options.encryptStorage=false] - **Only if the platform supports it.**\n * If set to `true` all items in all storage spaces are encrypted. Storage space \"private\" is\n * always encrypted.\n * @param {string|null} [options.secretForStorageKey] - This secret is used to derive a key to be\n * used to en- and decrypt all items in all storage spaces, or only the ones in \"private\",\n * depending on the value of `encryptStorage`.\n * @returns {Promise<undefined>}\n * @throws {Error} Throws an `Error` if the first parameter is not a hash\n */\nasync function initStorage({ instanceIdHash, wipeStorage = false, name, nHashCharsForSubDirs = 0, encryptStorage = false, secretForStorageKey // eslint-disable-line @typescript-eslint/no-unused-vars\n }) {\n    if (encryptStorage) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-INIT5');\n    }\n    (0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.setBaseDirOrName)(name);\n    const instanceDir = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.getBaseDirOrName)(), instanceIdHash);\n    // Prepend the given directory to the already chosen subdirectory names. The storage space\n    // for BLOBs is shared across all instances, all others are per Instance ID hash.\n    // NOTE: We use the existing object already assigned to STORAGE_DIRS instead of assigning a\n    // new object deliberately to avoid problems with other modules' imports of that\n    // object reference.\n    for (const key of Object.keys(STORAGE_DIRS)) {\n        STORAGE_DIRS[key] = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)(instanceDir, key);\n    }\n    // Assumption: If the instance directory exists then the entire directory structure exists.\n    // There will be a crash if there is one missing, but that is okay - there is no way to\n    // deal with randomly missing essential files. If we dealt with such a problem silently we\n    // might miss an issue of accidental file deletion!\n    const instanceExists = await fileExists(instanceDir);\n    if (instanceExists && wipeStorage) {\n        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.rm)(instanceDir, { recursive: true, maxRetries: 3 });\n    }\n    if (!instanceExists || wipeStorage) {\n        await createStorageDirs(nHashCharsForSubDirs);\n    }\n}\n/**\n * @internal\n * @static\n * @returns {undefined}\n */\nfunction closeStorage() {\n    for (const key of Object.keys(STORAGE_DIRS)) {\n        STORAGE_DIRS[key] = '';\n    }\n}\n/**\n * Deletes the storage folder by the given instanceIdHash if it exists.\n * @internal\n * @static\n * @async\n * @param {SHA256IdHash<Instance>} instanceIdHash\n * @returns {Promise<void>}\n */\nasync function deleteStorage(instanceIdHash) {\n    // This check added to prevent rm() below from removing something it shouldn't.\n    if (!(0,_util_type_checks_js__WEBPACK_IMPORTED_MODULE_9__.isHash)(instanceIdHash)) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-DELST1', { instanceIdHash });\n    }\n    const directoryPath = (0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.getBaseDirOrName)() ?? _storage_base_js__WEBPACK_IMPORTED_MODULE_10__.DEFAULT_STORAGE_LOCATION;\n    const storage = await doesStorageExist(instanceIdHash);\n    if (!storage) {\n        return;\n    }\n    // In case we get a slash-using path string, normalize for the current platform\n    const normalizedBaseDir = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)(directoryPath.startsWith(path__WEBPACK_IMPORTED_MODULE_3__.sep) ? path__WEBPACK_IMPORTED_MODULE_3__.sep : '', ...directoryPath.split(path__WEBPACK_IMPORTED_MODULE_3__.sep));\n    const instanceDir = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)(normalizedBaseDir, instanceIdHash);\n    return await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.rm)(instanceDir, {\n        recursive: true,\n        maxRetries: 3\n    }).catch((err) => {\n        if (err.code !== 'ENOENT') {\n            throw err;\n        }\n    });\n}\n/**\n * Checks if the instance exists or not.\n * @internal\n * @static\n * @async\n * @param {SHA256IdHash<Instance>} instanceIdHash\n * @returns {Promise<boolean>}\n */\nasync function doesStorageExist(instanceIdHash) {\n    const directoryPath = (0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.getBaseDirOrName)() ?? _storage_base_js__WEBPACK_IMPORTED_MODULE_10__.DEFAULT_STORAGE_LOCATION;\n    // In case we get a slash-using path string, normalize for the current platform\n    const normalizedBaseDir = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)(directoryPath.startsWith(path__WEBPACK_IMPORTED_MODULE_3__.sep) ? path__WEBPACK_IMPORTED_MODULE_3__.sep : '', ...directoryPath.split(path__WEBPACK_IMPORTED_MODULE_3__.sep));\n    const instanceDir = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)(normalizedBaseDir, instanceIdHash);\n    return await fileExists(instanceDir);\n}\n/**\n * Promisified version of node.js method fs.readFile(). `ENOENT` errors are normalized to\n * `FileNotFound`.\n * @internal\n * @static\n * @async\n * @param {string} filename\n * @param {StorageDirTypes} [type='objects']\n * @returns {Promise<string>} Resolves with a string. The promise is rejected if the file does\n * not exist.\n * @throws {Error} Rejects with an `Error` if no filename is given\n * @throws {Error} Rejects with an Error object whose name property is set to `FileNotFoundError`\n * if the file cannot be found\n */\nasync function readUTF8TextFile(filename, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if (filename === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-READ1');\n    }\n    // By specifying an encoding we get a UTF-8 string instead of a raw buffer.\n    // See the note at the top about the use of .catch()\n    return await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile)(normalizeFilename(filename, type), 'utf8').catch((err) => {\n        if (err.code === 'ENOENT') {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-READ2', { name: 'FileNotFoundError', filename, type });\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-READ', err);\n    });\n}\n/**\n * Read *a section* of the given UTF-8 encoded file as string. If the file has a bOM the offset\n * will be off. If a UTF-8 character used in the file uses more than one byte the offset will be\n * off. That is why unless you calculate the byte offset yourself the byte offset only matches the\n * character offset in the Javascript string representation of the file contents if the file\n * only contains characters from the ASCII-compatible section of UTF-8 codes.\n * @internal\n * @static\n * @async\n * @param {string} filename\n * @param {number} offset - **Byte*** offset: Where to start reading the UTF-8 encoded file. If the\n * offset is negative it is counted backwards from the end of the file. If the offset is\n * negative it is counted backwards from the end of the file.\n * @param {number} length - **Byte** length: How many bytes to read starting at the given offset\n * (always forward).\n * @returns {Promise<string>} - Returns the given section converted to a Javascript string\n * @param {StorageDirTypes} [type='objects']\n * @throws {Error} Throws an `Error` if a parameter is missing\n * @throws {Error} Throws an Error whose name property is set to `FileNotFoundError` if the file\n * cannot be found\n */\nasync function readTextFileSection(filename, offset, length, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if (!(0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(filename) || !(0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isInteger)(offset) || !(0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isInteger)(length)) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RASEC1', { filename, type, offset, length });\n    }\n    const fd = await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.open)(normalizeFilename(filename, type), 'r').catch(err => {\n        if (err.code === 'ENOENT') {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RASEC2', {\n                name: 'FileNotFoundError',\n                filename,\n                type,\n                offset,\n                length\n            });\n        }\n        throw err;\n    });\n    const stats = await fd.stat();\n    if (offset < 0) {\n        if (-offset < length) {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RASEC3', { filename, type, offset, length });\n        }\n        if (-offset > stats.size) {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RASEC4', { filename, type, offset, length, size: stats.size });\n        }\n    }\n    else if (offset + length > stats.size) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RASEC5', { filename, type, offset, length, size: stats.size });\n    }\n    const { buffer } = await fd.read(Buffer.alloc(length), 0, length, offset < 0 ? stats.size + offset : offset);\n    await fd.close();\n    return buffer.toString('utf-8');\n}\n/**\n * **Note that existing files will NOT be overwritten!** That is because this function is\n * made for our special context, where all files are stored under their SHA-256 hash as name, so\n * overwriting a file would make no sense.\n * @internal\n * @static\n * @async\n * @param {string} contents\n * @param {string} filename - Plain filename relative to STORAGE_DIRS\n * @param {StorageDirTypes} [type='objects']\n * @returns {Promise<FileCreationStatus>} A promise resolving with the enum-type\n * creation status string (new, exists).\n * @throws {Error} Throws an `Error` if no filename and/or no contents is given\n */\nasync function writeUTF8TextFile(contents, filename, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if (contents === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WRITE1');\n    }\n    if (filename === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WRITE2');\n    }\n    // Flag 'wx' - Like 'w' but fails if path exists\n    // See the note at the top about the use of .catch()\n    return await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile)(normalizeFilename(filename, type), contents, { flag: 'wx' })\n        .then(() => _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.NEW)\n        .catch((err) => {\n        if (err.code === 'EEXIST') {\n            return _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.EXISTS;\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WRITE', err);\n    });\n}\n/**\n * **Note that existing files will be overwritten!**\n * @internal\n * @static\n * @async\n * @param {string} contents\n * @param {string} filename - Plain filename relative to STORAGE_DIRS\n * @param {('vheads'|'rmaps')} type\n * @returns {Promise<FileCreationStatus>} A promise resolving with the enum-type\n * creation status string (new).\n * @throws {Error} Throws an `Error` if no filename and/or no contents is given, or if the 3rd\n * parameter is not \"rmaps\" or \"vheads\"\n */\nasync function writeUTF8SystemMapFile(contents, filename, type) {\n    if (contents === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WRITEM1');\n    }\n    if (filename === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WRITEM2');\n    }\n    if (type !== _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.RMAPS && type !== _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.VHEADS) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WRITEM3', { type });\n    }\n    // 'w' - Override existing file\n    // See the note at the top about the use of .catch()\n    return await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile)((0,path__WEBPACK_IMPORTED_MODULE_3__.join)(STORAGE_DIRS[type], filename), contents)\n        .then(() => _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.NEW)\n        .catch((err) => {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WRITEM', err);\n    });\n}\n/**\n * **This function is reserved for system internal version-map and reverse-map files.**\n * @see {@link\n *     system/storage-base.module:ts.writeUTF8TextFile|system/storage-base.writeUTF8TextFile}\n * @internal\n * @static\n * @async\n * @param {string} contents\n * @param {string} filename - Plain filename without directory\n * @param {('vheads'|'rmaps')} type\n * @returns {Promise<FileCreationStatus>} A promise resolving with the enum-type\n * creation status string which always is \"new\" to be consistent with the writeUTF8TextFile()\n * method\n * @throws {Error} Throws an `Error` if no filename and/or no contents is given, or if the 3rd\n * parameter is not \"rmaps\" or \"vheads\"\n */\nasync function appendUTF8SystemMapFile(contents, filename, type) {\n    if (contents === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-APPEND1');\n    }\n    if (filename === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-APPEND2');\n    }\n    if (type !== _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.RMAPS && type !== _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.VHEADS) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-APPEND3', { type });\n    }\n    let status = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.EXISTS;\n    try {\n        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.appendFile)((0,path__WEBPACK_IMPORTED_MODULE_3__.join)(STORAGE_DIRS[type], filename), contents, { flag: O_APPEND | O_WRONLY });\n    }\n    catch (err) {\n        if (err.code === 'ENOENT') {\n            status = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.NEW;\n        }\n        else {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-APPEND4', err);\n        }\n    }\n    if (status === _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.NEW) {\n        try {\n            await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.appendFile)((0,path__WEBPACK_IMPORTED_MODULE_3__.join)(STORAGE_DIRS[type], filename), contents, {\n                flag: O_APPEND | O_CREAT | O_WRONLY\n            });\n        }\n        catch (err) {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-APPEND5', err);\n        }\n    }\n    return status;\n}\n/**\n * Reads a binary file from storage space \"private\". Storage encryption is ignored, the raw file is\n * returned.\n *\n * On node.js the file's contents always is returned as `ArrayBuffer`, even if it is a UTF-8 text\n * file.\n * @internal\n * @static\n * @async\n * @param {string} filename\n * @returns {Promise<ArrayBuffer>}\n */\nasync function readPrivateBinaryRaw(filename) {\n    if (!(0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(filename)) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RPBR1', { filename });\n    }\n    // By specifying an encoding we get a UTF-8 string instead of a raw buffer.\n    // See the note at the top about the use of .catch()\n    return (0,_util_buffer_js__WEBPACK_IMPORTED_MODULE_11__.getArrayBuffer)(await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile)(normalizeFilename(filename, _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.PRIVATE)).catch((err) => {\n        if (err.code === 'ENOENT') {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RPBR3', {\n                name: 'FileNotFoundError',\n                filename,\n                type: _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.PRIVATE\n            });\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RPBR2', { err, filename });\n    }));\n}\n/**\n * Write a binary file from storage space \"private\". Storage encryption is ignored, the raw\n * ArrayBuffer is written. If the file already exists the promise is rejected with an Error.\n * @internal\n * @static\n * @async\n * @param {string} filename\n * @param {ArrayBufferLike | Uint8Array} contents\n * @returns {Promise<void>}\n */\nasync function writePrivateBinaryRaw(filename, contents) {\n    if (!(contents instanceof ArrayBuffer ||\n        contents instanceof SharedArrayBuffer ||\n        contents instanceof Uint8Array)) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WPBR1', { type: typeof contents, filename });\n    }\n    if (!(0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(filename)) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WPBR2', filename);\n    }\n    // Flag 'wx' - Like 'w' but fails if path exists\n    // See the note at the top about the use of .catch()\n    // Usage of Buffer.from(): \"This creates a view of the ArrayBuffer without copying the\n    // underlying memory\" (from the node.js docs)\n    // Also see https://github.com/nodejs/node/issues/42228\n    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile)(normalizeFilename(filename, _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.PRIVATE), Buffer.from((0,_util_buffer_js__WEBPACK_IMPORTED_MODULE_11__.getArrayBuffer)(contents)), {\n        flag: 'wx'\n    }).catch((err) => {\n        if (err.code === 'EEXIST') {\n            // Only in \"objects\" storage, where the filename is the hash of the contents,\n            // can this be ignored. Here, overwriting existing files is a problem.\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WPBR3', { filename });\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-WPBR4', { err, filename });\n    });\n}\n/**\n * This function supports the higher-level storage function that determines a stored files type.\n * By default, the first 100 bytes are interpreted as UTF-8 characters and returned, but starting\n * position as well as the number of bytes can be adjusted.\n * If the function reads less than `length` characters it just returns what it was able to get\n * without raising an exception. If the file was shorter so be it, in the context of our main use\n * case, which is to get the beginning of the microdata string of a ONE object in storage to\n * determine the type, this is not an error condition.\n * @private\n * @static\n * @async\n * @param {string} filename\n * @param {number} [position=0]\n * @param {number} [length=100]\n * @returns {Promise<string>} Returns length characters of the contents of the given file.\n * @throws {Error} Throws an `Error` if no filename is given\n * @throws {Error} Throws an Error object whose name property is set to `FileNotFoundError` if the\n * file cannot be found\n */\nfunction getNCharacters(filename, position = 0, length = 256) {\n    return new Promise((resolve, reject) => {\n        if (filename === undefined) {\n            reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-GETN1'));\n        }\n        const stream = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createReadStream)(normalizeFilename(filename), {\n            start: position,\n            end: position + length\n        });\n        stream.on('error', (err) => {\n            if (err.code === 'ENOENT') {\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-GETN2', {\n                    name: 'FileNotFoundError',\n                    filename,\n                    type: _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS\n                }));\n            }\n            else {\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-GETN5', err));\n            }\n        });\n        let content = '';\n        stream.on('data', (chunk) => {\n            if ((0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(chunk)) {\n                content += chunk;\n            }\n            else if ((0,buffer__WEBPACK_IMPORTED_MODULE_0__.isUtf8)(chunk)) {\n                content += chunk.toString('utf8');\n            }\n            else {\n                return reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-RD-NOSTR', { filename }));\n            }\n        });\n        stream.on('end', () => resolve(content));\n    });\n}\n/**\n * @internal\n * @static\n * @async\n * @param {string} filename\n * @param {StorageDirTypes} [type='objects']\n * @returns {Promise<boolean>}\n * @throws {Error} Throws an `Error` if no filename is given\n */\nasync function exists(filename, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if (filename === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-EXISTS');\n    }\n    return await fileExists(normalizeFilename(filename, type));\n}\n/**\n * Uses node.js \"fs.promises.stat\" and the \"size\" property on the Stat object to get the file size.\n * @internal\n * @static\n * @async\n * @param {string} filename\n * @param {StorageDirTypes} [type='objects']\n * @returns {Promise<number>}\n * @throws {Error} Throws an `Error` if no filename is given\n */\nasync function fileSize(filename, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if (filename === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-FSIZE1');\n    }\n    const stats = await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.stat)(normalizeFilename(filename, type)).catch((err) => {\n        if (err.code === 'ENOENT') {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-FSIZE2', { name: 'FileNotFoundError', filename, type });\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-FSIZE3', err);\n    });\n    return stats.size;\n}\n/**\n * @internal\n * @static\n * @async\n * @returns {Promise<SHA256Hash[]>}\n */\nasync function listAllObjectHashes() {\n    // See the note at the top about the use of .catch()\n    if (SUB_DIR_LVL === 0) {\n        return (await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir)(STORAGE_DIRS.objects).catch((err) => {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-LH', err);\n        }));\n    }\n    const subdirs = await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir)(STORAGE_DIRS.objects).catch((err) => {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-LH', err);\n    });\n    const files = await Promise.all(subdirs.map(subdir => (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir)((0,path__WEBPACK_IMPORTED_MODULE_3__.join)(STORAGE_DIRS.objects, subdir)).catch((err) => {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-LH', err);\n    })));\n    return (0,_util_function_js__WEBPACK_IMPORTED_MODULE_6__.flat)(files);\n}\n/**\n * @internal\n * @static\n * @async\n * @returns {Promise<SHA256IdHash[]>}\n */\nasync function listAllIdHashes() {\n    // See the note at the top about the use of .catch()\n    return (await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir)(STORAGE_DIRS[_storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.VHEADS]).catch((err) => {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-LIH', err);\n    }));\n}\n/**\n * @internal\n * @static\n * @async\n * @param {string} [prefix]\n * @returns {Promise<string[]>}\n */\nasync function listAllReverseMapNames(prefix) {\n    // See the note at the top about the use of .catch()\n    const files = await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir)(STORAGE_DIRS[_storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.RMAPS]).catch((err) => {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SB-LM', err);\n    });\n    return (0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(prefix) ? files.filter(file => file.startsWith(prefix)) : files;\n}\n/**\n * Reads the first 100 characters of the given object and returns its type. If it is not a ONE\n * object it simply returns \"BLOB\".\n * @internal\n * @static\n * @async\n * @param {(SHA256Hash|SHA256IdHash)} hash - Hash identifying a ONE object in storage\n * @returns {Promise<string|'BLOB'>} The type string of the given microdata object, or 'BLOB'\n * if the given string does not look like ONE object microdata\n */\nasync function getFileType(hash) {\n    let firstChars;\n    try {\n        firstChars = await getNCharacters(hash);\n    }\n    catch (err) {\n        if (err.code === 'SB-RD-NOSTR') {\n            return 'BLOB';\n        }\n        throw err;\n    }\n    return (0,_util_object_js__WEBPACK_IMPORTED_MODULE_7__.getTypeFromMicrodata)(firstChars);\n}\n/**\n * @internal\n * @static\n * @async\n * @param {string} _oldSecret\n * @param {string} _newSecret\n * @returns {Promise<void>}\n */\nasync function changeStoragePassword(_oldSecret, _newSecret) {\n    // This platform does not support storage encryption, so there is nothing to do.\n    return;\n}\n//# sourceMappingURL=storage-base.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/storage-base.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/storage-streams.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/storage-streams.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFileReadStream: () => (/* binding */ createFileReadStream),\n/* harmony export */   createFileWriteStream: () => (/* binding */ createFileWriteStream)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../errors.js */ \"../node_modules/@refinio/one.core/lib/errors.js\");\n/* harmony import */ var _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../storage-base-common.js */ \"../node_modules/@refinio/one.core/lib/storage-base-common.js\");\n/* harmony import */ var _util_one_event_source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/one-event-source.js */ \"../node_modules/@refinio/one.core/lib/util/one-event-source.js\");\n/* harmony import */ var _util_promise_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/promise.js */ \"../node_modules/@refinio/one.core/lib/util/promise.js\");\n/* harmony import */ var _util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/type-checks-basic.js */ \"../node_modules/@refinio/one.core/lib/util/type-checks-basic.js\");\n/* harmony import */ var _storage_base_delete_file_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./storage-base-delete-file.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/storage-base-delete-file.js\");\n/* harmony import */ var _storage_base_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./storage-base.js */ \"../node_modules/@refinio/one.core/lib/system/nodejs/storage-base.js\");\n/* harmony import */ var _util_buffer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/buffer.js */ \"../node_modules/@refinio/one.core/lib/util/buffer.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2017\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @private\n * @module\n */\n/*\n * NOTE ABOUT ERRORS AND PROMISE STYLE (promise.catch instead of try/catch)\n *\n * Low-level functions for file-access don't throw standard Javascript errors, they throw\n * node.js SYSTEM errors. Ref.: https://nodejs.org/api/errors.html#errors_system_errors\n *\n * When calling node.js fs methods we use .catch() instead of try/catch because\n *\n * 1. Only the former manages to enable async. stack trace creation (a feature available in\n *    recent node.js/V8)\n * 2. We also need to throw a createError(err) to get the stack trace. The one we get from Node.js\n *    does not have it. Our createError() method always creates a createError.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Promisified version of node.js file rename method. This \"rename\" refuses to replace an\n * already existing file - which is to support higher level code in recognizing that an object\n * already exists. That prevents \"new object\" events, which usually lead to actions like adding\n * the new object to one or more maps, and all that work is not necessary if a file with the\n * same hash and therefore the same contents already exists.\n * @private\n * @param {string} oldName - Old filename\n * @param {string} newName - New filename\n * @param {StorageDirTypes} [type='objects']\n * @returns {Promise<FileCreationStatus>} A promise resolving with the enum-type creation\n * status string (new, exists)\n */\nasync function moveFromTempToObjectSpace(oldName, newName, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if (oldName === undefined || newName === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-MV1', { oldName, newName });\n    }\n    const oldWithPath = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.getStorageDirForFileType)(_storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.TMP), oldName);\n    const newWithPath = (0,path__WEBPACK_IMPORTED_MODULE_3__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.normalizeFilename)(newName, type));\n    // If renaming fails because the file already exists we delete the temporary file. The\n    // context is the fact that ONE stores files under the SHA-256 of their contents, so if\n    // something already exists we conclude the exact same file already exists, and there\n    // is therefore no point in keeping the old one around.\n    // PROMISE CHAIN METHODS ARE DELIBERATE, SEE NOTE AT TOP\n    return await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.stat)(newWithPath)\n        .then(stats => {\n        if (stats.isFile()) {\n            // The target file already exists (and we assume it is the exact same contents)\n            return (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.unlink)(oldWithPath)\n                .then(() => _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.EXISTS)\n                .catch((unlinkErr) => {\n                if (unlinkErr.code === 'ENOENT') {\n                    // The file we were supposed to rename no longer exists. While this is\n                    // seemingly okay since the target already exists so that it seems we've\n                    // got what we wanted the disappearance of the file is unexpected.\n                    throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-MV2', {\n                        name: 'FileNotFoundError',\n                        filename: oldName,\n                        type: _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.TMP\n                    });\n                }\n                throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-MV6', unlinkErr);\n            });\n        }\n        // This is an \"impossible\" error, but you never know\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-MV7', { old: oldWithPath, new: newWithPath });\n    })\n        .catch((err) => {\n        if (err.code === 'ENOENT') {\n            // \"No such file or directory\" - perfect, go ahead.\n            return (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.rename)(oldWithPath, newWithPath)\n                .then(() => _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.CREATION_STATUS.NEW)\n                .catch((renameErr) => {\n                if (renameErr.code === 'ENOENT') {\n                    throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-MV3', {\n                        name: 'FileNotFoundError',\n                        filename: oldName,\n                        type: _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.TMP\n                    });\n                }\n                throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-MV4', renameErr);\n            });\n        }\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-MV5', err);\n    });\n}\n/**\n * @internal\n * @static\n * @param {SHA256Hash} hash - Hash (and filename) of a ONE object, CLOB or BLOB\n * @param {('base64'|'utf8')} [encoding] - Use 'utf8' for streams of UTF-8 text files if you want\n * them streamed as UTF-8 (otherwise they are just treated as binary streams). Everything else is\n * treated as \"binary\" and can be streamed as pure binary stream (ArrayBuffer, leave this\n * parameter undefined), or as base64 encoded binary stream (the React Native platform does not\n * support getting binary data across the native-to-Javascript bridge and requires all binary\n * data to be base64 encoded).\n *\n * For BLOBSs:\n * - undefined: binary stream (ArrayBuffer)\n * - 'base64': base64 encoded binary stream\n *\n * For ONE objects and CLOBs:\n * - 'utf8': UTF-8 string stream of UTF-8 contents\n * @returns {SimpleReadStream} Returns a simple platform-independent readable stream.\n * @throws {Error} Throws a synchronous `Error` if no filename is given\n * @throws {Error} Throws an Error whose name is `FileNotFoundError` if the version map does not\n * exist\n */\nfunction createFileReadStream(hash, encoding) {\n    if (hash === undefined) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CR1');\n    }\n    // node.js default highWaterMark of 64 kb; autoClose default: true\n    const stream = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createReadStream)((0,path__WEBPACK_IMPORTED_MODULE_3__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.normalizeFilename)(hash)), { encoding });\n    const streamTracker = (0,_util_promise_js__WEBPACK_IMPORTED_MODULE_7__.createTrackingPromise)();\n    const onDataEvents = (0,_util_one_event_source_js__WEBPACK_IMPORTED_MODULE_6__.createEventSource)();\n    // Stream starts in the next event loop iteration as soon as the first (and only) event\n    // handler is subscribed\n    onDataEvents.onListenerChange = (_oldSize, newSize) => {\n        if (newSize !== 1) {\n            stream.removeAllListeners('data');\n            stream.pause();\n        }\n        if (newSize > 1) {\n            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CR2');\n        }\n        if (newSize === 0) {\n            return;\n        }\n        // SPECIAL TREATMENT for the last chunk of binary buffer chunks is the\n        // reason for this if(), otherwise this would be a one-line statement\n        if (encoding === undefined) {\n            // Our normalized simple stream API promises an ArrayBuffer object\n            // https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_buf_buffer\n            stream.on('data', (data) => {\n                // The last chunk does not use the full buffer size. slice()\n                // creates a copy, that's why we only do this when necessary.\n                if ((0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(data)) {\n                    onDataEvents.dispatch(data);\n                }\n                else if (data.byteOffset !== 0 || data.byteLength < data.buffer.byteLength) {\n                    onDataEvents.dispatch(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));\n                }\n                else {\n                    onDataEvents.dispatch(data.buffer);\n                }\n            });\n        }\n        else {\n            stream.on('data', (data) => {\n                if ((0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(data)) {\n                    onDataEvents.dispatch(data);\n                }\n                else {\n                    onDataEvents.dispatch(data.toString(encoding));\n                }\n            });\n        }\n        stream.resume();\n    };\n    // No need to close the underlying platform stream since \"autoClose\" is true by default\n    stream.on('error', (err) => {\n        if (err.code === 'ENOENT') {\n            streamTracker.reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CR3', {\n                name: 'FileNotFoundError',\n                filename: hash,\n                type: _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS\n            }));\n        }\n        else {\n            streamTracker.reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CR4', err));\n        }\n    });\n    // https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_event_end\n    // The 'end' event is emitted when there is no more data to be consumed from the stream.\n    // The 'end' event will not be emitted unless the data is completely consumed.\n    stream.on('end', () => {\n        streamTracker.resolve();\n    });\n    return {\n        encoding: encoding,\n        onData: onDataEvents.consumer,\n        pause: () => {\n            stream.pause();\n        },\n        resume: () => {\n            stream.resume();\n        },\n        cancel: () => {\n            stream.destroy((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CR6'));\n        },\n        promise: streamTracker.promise\n    };\n}\n/**\n * Have a look at the description of the {@link SimpleWriteStream} object returned by the method\n * for coding style information (purpose of \"promise\" property, for example).\n * @internal\n * @static\n * @param {('base64'|'utf8')} [encoding] - 'utf8' for text file streams or 'base64' for base64\n * encoded string streams, `undefined` for binary streams\n * @param {string} [filename]\n * @param {StorageDirTypes} [type='objects']\n * @returns {SimpleWriteStream} Returns a simple platform-independent writable stream.\n */\nfunction createFileWriteStream(encoding, filename, type = _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n    if ((0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(filename) && type === _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.OBJECTS) {\n        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-PARA1', { filename });\n    }\n    // Generate a random name for the temporary file by creating a random number sequence of\n    // bytes and converting it to a hex string (string length will be twice the number of\n    // bytes).\n    const tmpFile = (0,_storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.createTempFileName)();\n    // By definition ONE saves everything using the crypto-hash over the entire buffer (or\n    // string) as identifier. Which crypto hash function is used does not matter as long as\n    // it is consistent.\n    const cryptoHashObj = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)('sha256');\n    const stream = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)((0,path__WEBPACK_IMPORTED_MODULE_3__.join)((0,_storage_base_js__WEBPACK_IMPORTED_MODULE_10__.getStorageDirForFileType)(_storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.TMP), tmpFile), {\n        encoding\n    });\n    const streamTracker = (0,_util_promise_js__WEBPACK_IMPORTED_MODULE_7__.createTrackingPromise)();\n    stream.once('error', (err) => {\n        // According to node.js 12.x API docs at\n        // https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_event_error\n        // > \"The stream is not closed when the 'error' event is emitted.\"\n        // destroy() is new since v8, and close() has been removed from the documentation. At\n        // least right now (v8) destroy() calls close(), but we use the newer function.\n        // Also see comment at https://github.com/nodejs/node/issues/2006#issuecomment-314070986\n        stream.destroy();\n        // Remove the temporary file and ignore errors occurring during that step - that error\n        // would be secondary to the one we are already dealing with\n        (0,_storage_base_delete_file_js__WEBPACK_IMPORTED_MODULE_9__.deleteFile)(tmpFile, _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.TMP)\n            .finally(() => streamTracker.reject(err))\n            // Promise failure is handled elsewhere, but we need to handle\n            // rejections of the new Promise created by the finally() method\n            .catch(_ => undefined);\n    });\n    function writeFn(data) {\n        let buf;\n        if ((0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(data)) {\n            // This is a UTF-8 text file or a base64 encoded binary chunk\n            if (encoding === undefined) {\n                cancelFn().catch(_ => undefined);\n                return streamTracker.reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CW2'));\n            }\n            buf = Buffer.from(data, encoding);\n        }\n        else {\n            if (encoding !== undefined) {\n                cancelFn().catch(_ => undefined);\n                return streamTracker.reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CW3', { encoding }));\n            }\n            buf = Buffer.from((0,_util_buffer_js__WEBPACK_IMPORTED_MODULE_11__.getArrayBuffer)(data));\n        }\n        cryptoHashObj.update(buf);\n        stream.write(buf);\n    }\n    function cancelFn() {\n        // Different points of view: For 3rd party listeners on the stream promise follow-up\n        // errors don't matter, for them the cancellation of the stream itself is the error.\n        streamTracker.reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CAN'));\n        return new Promise((resolve, reject) => {\n            // This 'error' handler only is for the cancel() command's promise.\n            stream.once('error', err => {\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CAN1', err));\n            });\n            // Orderly end: Just finish with whatever we got thus far and then remove the\n            // temporary stream file\n            stream.end(() => {\n                (0,_storage_base_delete_file_js__WEBPACK_IMPORTED_MODULE_9__.deleteFile)(tmpFile, _storage_base_common_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.TMP)\n                    .then(() => resolve())\n                    .catch((err) => {\n                    reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-CAN2', err));\n                });\n            });\n        });\n    }\n    function endFn() {\n        return new Promise((resolve, reject) => {\n            // This 'error' handler only is for the stream.end() command's promise.\n            stream.once('error', (err) => {\n                reject((0,_errors_js__WEBPACK_IMPORTED_MODULE_4__.createError)('SST-WEND', err));\n            });\n            // https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_event_finish\n            // The 'finish' event is emitted after the stream.end() method has been called, and\n            // all data has been flushed to the underlying system.\n            stream.once('finish', () => {\n                const hash = ((0,_util_type_checks_basic_js__WEBPACK_IMPORTED_MODULE_8__.isString)(filename) ? filename : cryptoHashObj.digest('hex'));\n                moveFromTempToObjectSpace(tmpFile, hash, type)\n                    .then(status => {\n                    const result = {\n                        hash,\n                        status\n                    };\n                    // Tell 3rd party listeners of the stream promise\n                    streamTracker.resolve(result);\n                    // Tell caller of end()\n                    resolve(result);\n                })\n                    .catch((err) => {\n                    streamTracker.reject(err);\n                    reject(err);\n                });\n            });\n            stream.end();\n        });\n    }\n    return {\n        write: writeFn,\n        cancel: cancelFn,\n        end: endFn,\n        promise: streamTracker.promise\n    };\n}\n//# sourceMappingURL=storage-streams.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/storage-streams.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/nodejs/websocket.js":
/*!************************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/nodejs/websocket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWebSocket: () => (/* binding */ createWebSocket)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"../node_modules/ws/wrapper.mjs\");\n/**\n * @author Maximilian Wisgickl <wisgicklma@gmail.com>\n * @copyright REFINIO GmbH 2018\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n/**\n * @private\n * @module\n */\n\n/**\n * Create a WebSocket object. On react-native and browser this is a native object, on node.js a\n * package like \"ws\" (or \"uws\") is needed.\n * @internal\n * @static\n * @param {string} url\n * @returns {WebSocket}\n */\nfunction createWebSocket(url) {\n    return new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocket(url);\n}\n//# sourceMappingURL=websocket.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/nodejs/websocket.js?\n}");

/***/ }),

/***/ "../node_modules/@refinio/one.core/lib/system/post-json.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@refinio/one.core/lib/system/post-json.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   postJson: () => (/* binding */ postJson),\n/* harmony export */   setPlatformForPj: () => (/* binding */ setPlatformForPj)\n/* harmony export */ });\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ \"../node_modules/@refinio/one.core/lib/system/platform.js\");\n/**\n * @author Michael Hasenstein <hasenstein@yahoo.com>\n * @copyright REFINIO GmbH 2023\n * @license CC-BY-NC-SA-2.5; portions MIT License\n * @version 0.0.1\n */\n\nlet PJ;\nfunction setPlatformForPj(exports) {\n    PJ = exports;\n}\n/**\n * Post a JSON string to a remote location via HTTPRequest (POST)\n * @param {string} url - A URL to a remote location. If relative, it is relative to the loaded\n * app if this is called from a browser.\n * @param {string} jsonContent - Already stringified JSON\n * @returns {Promise<void>}\n */\nfunction postJson(url, jsonContent) {\n    (0,_platform_js__WEBPACK_IMPORTED_MODULE_0__.ensurePlatformLoaded)();\n    return PJ.postJson(url, jsonContent);\n}\n//# sourceMappingURL=post-json.js.map\n\n//# sourceURL=webpack://one-filer-login/../node_modules/@refinio/one.core/lib/system/post-json.js?\n}");

/***/ }),

/***/ "../node_modules/ws/wrapper.mjs":
/*!**************************************!*\
  !*** ../node_modules/ws/wrapper.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"../node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"../node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"../node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"../node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"../node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n//# sourceURL=webpack://one-filer-login/../node_modules/ws/wrapper.mjs?\n}");

/***/ })

};
;