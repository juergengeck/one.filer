"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "src_filer_FuseFrontend_js";
exports.ids = ["src_filer_FuseFrontend_js"];
exports.modules = {

/***/ "../src/filer/FuseFrontend.js":
/*!************************************!*\
  !*** ../src/filer/FuseFrontend.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n\nvar __importDefault = (undefined && undefined.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FuseFrontend = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst FuseApiToIFileSystemAdapter_1 = __importDefault(require(\"./FuseApiToIFileSystemAdapter\"));\nconst fuseHelper_1 = require(\"../misc/fuseHelper\");\nconst typeChecks_1 = require(\"../utils/typeChecks\");\nconst index_js_1 = require(\"../fuse/index.js\");\n/**\n *  This is a fuse frontend.\n */\nclass FuseFrontend {\n    fuseInstance = null;\n    Fuse;\n    /** Start the fuse frontend.\n     *\n     *  @param rootFileSystem - The file system implementation that should be mounted\n     *  @param mountPoint - Specifies the mount point where to mount the filesystem\n     *  @param logCalls - If true log all calls to console\n     *  @param fuseOptions - FUSE mount options for Windows/WSL2 compatibility\n     */\n    async start(rootFileSystem, mountPoint, logCalls = false, fuseOptions = {}) {\n        if (this.fuseInstance) {\n            throw Error('Fuse frontend already started');\n        }\n        // Get the platform-appropriate FUSE implementation\n        this.Fuse = await (0, index_js_1.getFuse)();\n        // Resolve mount point to absolute path\n        const absoluteMountPoint = path_1.default.resolve(mountPoint);\n        console.log(`ðŸ”§ Resolved mount point: ${mountPoint} -> ${absoluteMountPoint}`);\n        FuseFrontend.setupMountPoint(absoluteMountPoint);\n        // If we plan to have multiple implementations of the fuse API, then we need to move\n        // this part outside this class. But at the moment we don't plan to do it (The\n        // IFileSystem hopefully fits all), so it is easier not to expose this extra layer to\n        // the outside.\n        const fuseFileSystemAdapter = new FuseApiToIFileSystemAdapter_1.default(rootFileSystem, absoluteMountPoint, logCalls);\n        // Why fuseHandlers: Fuse.OPERATIONS\n        // THE TYPE HAS BEEN ADDED TO THAT THE FUNCTIONS ARE CHECKED AGAINST Fuse.OPERATIONS\n        // Fuse.OPERATIONS has all members set to \"optional\", which makes the type for\n        // fuseHandlers less exact, but the advantages of getting the API of the functions\n        // checked is higher than the inconvenience of getting an additional \"undefined\" into\n        // this type (which needs type assertion workarounds down in \"if (logCalls)\").\n        // Create map of file system handlers for fuse instance\n        const fuseHandlers = {\n            init: (cb) => {\n                console.log('ðŸ”§ FUSE init called');\n                fuseFileSystemAdapter.fuseInit(cb);\n            },\n            error: (err) => {\n                console.error('ðŸ”§ FUSE error called:', err);\n                fuseFileSystemAdapter.fuseError(() => { });\n            },\n            getattr: (path, cb) => {\n                console.log('ðŸ”§ FUSE getattr called:', path);\n                fuseFileSystemAdapter.fuseGetattr(path, cb);\n            },\n            readdir: (path, cb) => {\n                console.log('ðŸ”§ FUSE readdir called:', path);\n                fuseFileSystemAdapter.fuseReaddir(path, cb);\n            },\n            access: fuseFileSystemAdapter.fuseAccess.bind(fuseFileSystemAdapter),\n            statfs: fuseFileSystemAdapter.fuseStatfs.bind(fuseFileSystemAdapter),\n            fgetattr: fuseFileSystemAdapter.fuseFgetattr.bind(fuseFileSystemAdapter),\n            flush: fuseFileSystemAdapter.fuseFlush.bind(fuseFileSystemAdapter),\n            fsync: fuseFileSystemAdapter.fuseFsync.bind(fuseFileSystemAdapter),\n            fsyncdir: fuseFileSystemAdapter.fuseFsyncdir.bind(fuseFileSystemAdapter),\n            truncate: fuseFileSystemAdapter.fuseTruncate.bind(fuseFileSystemAdapter),\n            ftruncate: fuseFileSystemAdapter.fuseFtruncate.bind(fuseFileSystemAdapter),\n            readlink: fuseFileSystemAdapter.fuseReadlink.bind(fuseFileSystemAdapter),\n            chown: fuseFileSystemAdapter.fuseChown.bind(fuseFileSystemAdapter),\n            chmod: fuseFileSystemAdapter.fuseChmod.bind(fuseFileSystemAdapter),\n            mknod: fuseFileSystemAdapter.fuseMknod.bind(fuseFileSystemAdapter),\n            setxattr: fuseFileSystemAdapter.fuseSetxattr.bind(fuseFileSystemAdapter),\n            getxattr: (path, name, cb) => {\n                if (typeof cb !== 'function') {\n                    console.warn('ðŸ”§ FUSE getxattr called without callback:', { path, name });\n                    return;\n                }\n                fuseFileSystemAdapter.fuseGetxattr(path, name, 0, (err, xattr) => {\n                    cb(err, xattr || undefined);\n                });\n            },\n            listxattr: fuseFileSystemAdapter.fuseListxattr.bind(fuseFileSystemAdapter),\n            removexattr: fuseFileSystemAdapter.fuseRemovexattr.bind(fuseFileSystemAdapter),\n            open: fuseFileSystemAdapter.fuseOpen.bind(fuseFileSystemAdapter),\n            opendir: fuseFileSystemAdapter.fuseOpendir.bind(fuseFileSystemAdapter),\n            read: fuseFileSystemAdapter.fuseRead.bind(fuseFileSystemAdapter),\n            write: fuseFileSystemAdapter.fuseWrite.bind(fuseFileSystemAdapter),\n            release: fuseFileSystemAdapter.fuseRelease.bind(fuseFileSystemAdapter),\n            releasedir: fuseFileSystemAdapter.fuseReleasedir.bind(fuseFileSystemAdapter),\n            create: fuseFileSystemAdapter.fuseCreate.bind(fuseFileSystemAdapter),\n            utimens: (path, atime, mtime, cb) => {\n                fuseFileSystemAdapter.fuseUtimens(path, new Date(atime * 1000), new Date(mtime * 1000), cb);\n            },\n            unlink: fuseFileSystemAdapter.fuseUnlink.bind(fuseFileSystemAdapter),\n            rename: fuseFileSystemAdapter.fuseRename.bind(fuseFileSystemAdapter),\n            link: fuseFileSystemAdapter.fuseLink.bind(fuseFileSystemAdapter),\n            symlink: fuseFileSystemAdapter.fuseSymlink.bind(fuseFileSystemAdapter),\n            mkdir: fuseFileSystemAdapter.fuseMkdir.bind(fuseFileSystemAdapter),\n            rmdir: fuseFileSystemAdapter.fuseRmdir.bind(fuseFileSystemAdapter)\n        };\n        if (logCalls) {\n            for (const handlerId in fuseHandlers) {\n                const oldHandler = fuseHandlers[handlerId];\n                if (handlerId === 'init') {\n                    fuseHandlers[handlerId] = (...args) => FuseFrontend.logFuseCall(oldHandler, ...args);\n                }\n                else {\n                    fuseHandlers[handlerId] = (...args) => FuseFrontend.logFuseCallCB(handlerId, oldHandler, ...args);\n                }\n            }\n        }\n        // Merge user-provided FUSE options with defaults\n        const mountOptions = {\n            displayFolder: 'One FUSE',\n            ...fuseOptions\n        };\n        console.log('ðŸ”§ FUSE mount options:', mountOptions);\n        this.fuseInstance = new this.Fuse(absoluteMountPoint, fuseHandlers, mountOptions);\n        await new Promise((resolve, reject) => {\n            if (this.fuseInstance === null) {\n                reject(Error('Fuse frontend not yet started'));\n            }\n            else {\n                this.fuseInstance.mount((err) => (err === null ? resolve() : reject(err)));\n            }\n        });\n    }\n    /** Stop the fuse frontend. */\n    async stop() {\n        if (this.fuseInstance) {\n            return new Promise((resolve, reject) => {\n                if (this.fuseInstance === null) {\n                    reject(Error('Fuse frontend not yet started'));\n                }\n                else {\n                    this.fuseInstance.unmount((err) => (err === null ? resolve() : reject(err)));\n                }\n            });\n        }\n    }\n    static async isFuseNativeConfigured() {\n        const Fuse = await (0, index_js_1.getFuse)();\n        return new Promise((resolve, reject) => {\n            Fuse.isConfigured((err, isConfigured) => {\n                if (err !== null) {\n                    reject(err);\n                }\n                resolve(isConfigured);\n            });\n        });\n    }\n    static async configureFuseNative() {\n        const Fuse = await (0, index_js_1.getFuse)();\n        return new Promise((resolve, reject) => {\n            Fuse.configure(errConfigure => {\n                if (errConfigure) {\n                    reject(new Error(`\\x1b[31mError: ${errConfigure.message}\\x1b[0m`));\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n    }\n    // ############### PRIVATE Interface ###############\n    /**\n     * Sets up the mount point correctly for the current platform.\n     *\n     * @param mountPoint\n     */\n    static setupMountPoint(mountPoint) {\n        switch (process.platform) {\n            case 'win32':\n                // the mounting folder must not exist on win32\n                if (fs_1.default.existsSync(mountPoint)) {\n                    fs_1.default.rmdirSync(mountPoint);\n                }\n                break;\n            default:\n                if (!fs_1.default.existsSync(mountPoint)) {\n                    fs_1.default.mkdirSync(mountPoint);\n                }\n                break;\n        }\n    }\n    /** Function that logs a fuse call and forwards all arguments to the real handler.\n     *\n     *  This function is registered as fuse-native callback instead of the callback methods in this\n     *  class. It then logs the call and forwards it to the real callback\n     *\n     *  @param  handler - -  The callback implemented by this class. Calls are forwarded to this\n     *  handler\n     *  @param  args   -  Arguments that shall be passed to the handler\n     */\n    static logFuseCall(handler, ...args) {\n        handler(...args);\n    }\n    /** Function that logs a fuse call with callback and forwards all arguments to the real handler.\n     *\n     *  This function is registered as fuse-native callback instead of the callback methods in this\n     *  class. It then logs the call and forwards it to the real callback. It is also possible to\n     *  log the return values, but this is disabled at the moment because of a bug when executing\n     *  the application in the webstorm terminal\n     *\n     *  @param  name -  Name of fuse callback that is called by fuse-native\n     *  @param  handler - The callback implemented by this class. Calls are forwarded to it\n     *  @param  args -  Arguments that shall be passed to the handler\n     */\n    static logFuseCallCB(name, handler, ...args) {\n        const normalArgs = args.slice(0, -1);\n        const cbArg = args[args.length - 1];\n        if (!(0, typeChecks_1.isFunction)(cbArg)) {\n            throw new Error(`cbArg is not a function but ${typeof cbArg}: ${String(cbArg)}`);\n        }\n        // Call the normal arguments and with a special callback functions to intercept the answers\n        handler(...normalArgs, (...argscb) => {\n            /*\n             * Enabling logging of return values triggers a bug in Jetbrains for the getattr call\n             * when the *time fields contain a date object (only if you execute the process in\n             *  the jetbrains terminal).\n             * The result is jetbrains and the node process hangs.\n             * I have absolutely no idea why, but consider this when enabling this line\n             */\n            const returnedCode = parseInt(argscb[0], 10);\n            const route = String(normalArgs[0]) === '/'\n                ? '\\x1b[40mroot\\x1b[0m'\n                : String(normalArgs[0]).includes('/')\n                    ? `\\x1b[40m${(0, fuseHelper_1.splitRoutePath)(normalArgs[0]).prefix}\\x1b[0m`\n                    : '';\n            if (route === '.git') {\n                cbArg(...argscb);\n                return;\n            }\n            // it returned an error code\n            if (returnedCode < 0) {\n                console.log('\\x1b[33m[WARN]:\\x1b[0m', route, `| \\x1b[33m${name}(${String(normalArgs)}) -> `, `\\x1b[35m${String(argscb[0])}\\x1b[0m`);\n            }\n            else {\n                console.log('\\x1b[32m[INFO]:\\x1b[0m', route, `| ${name}(${String(normalArgs)}) -> \\x1b[35m${String(argscb[0])}\\x1b[0m`);\n            }\n            cbArg(...argscb);\n        });\n    }\n}\nexports.FuseFrontend = FuseFrontend;\n\n\n//# sourceURL=webpack://one-filer-login/../src/filer/FuseFrontend.js?\n}");

/***/ })

};
;