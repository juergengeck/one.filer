/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(net__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _services_ServiceManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./services/ServiceManager */ \"./src/services/ServiceManager.ts\");\n\n\n\n\n\n\n\n\n\nconst exec = (0,util__WEBPACK_IMPORTED_MODULE_3__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_2__.exec);\n// For CommonJS, __dirname is already available\n// Single instance lock\nconst gotTheLock = electron__WEBPACK_IMPORTED_MODULE_0__.app.requestSingleInstanceLock();\n// IPC server for inter-process communication\nlet ipcServer = null;\nconst IPC_PORT = 17890; // Fixed port for IPC communication\nlet mainWindow = null;\nlet credentials = null;\nlet replicantProcess = null;\nlet tray = null;\nlet isQuitting = false;\nlet replicantStartTime = null;\nlet serviceManager;\nlet metricsCache = {\n    objectsStored: 0,\n    objectsSynced: 0,\n    syncQueue: 0,\n    connections: 0,\n    lastSync: null,\n    errors: 0,\n    bandwidth: {\n        upload: 0,\n        download: 0\n    },\n    operations: {\n        reads: 0,\n        writes: 0,\n        deletes: 0\n    },\n    performance: {\n        avgResponseTime: 0,\n        requestsPerSecond: 0\n    }\n};\nlet config = {\n    startMinimized: false,\n    showInSystemTray: true,\n    autoConnect: false,\n    wslDistro: 'Ubuntu',\n    replicantPath: '/home/juerg/source/one.filer'\n};\n// Try to load config from file\nconst configPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(process.cwd(), 'config.json');\nif ((0,fs__WEBPACK_IMPORTED_MODULE_4__.existsSync)(configPath)) {\n    try {\n        const configData = (0,fs__WEBPACK_IMPORTED_MODULE_4__.readFileSync)(configPath, 'utf8');\n        config = { ...config, ...JSON.parse(configData) };\n    }\n    catch (error) {\n        console.error('Failed to load config:', error);\n    }\n}\nfunction createWindow() {\n    mainWindow = new electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow({\n        width: 1200,\n        height: 800,\n        minWidth: 1000,\n        minHeight: 700,\n        resizable: true,\n        show: !config.startMinimized,\n        webPreferences: {\n            nodeIntegration: false,\n            contextIsolation: true,\n            preload: (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(__dirname, 'preload.js')\n        },\n        icon: (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(__dirname, '..', 'assets', 'icon.png')\n    });\n    // Load the React-based app for better monitoring capabilities\n    mainWindow.loadFile((0,path__WEBPACK_IMPORTED_MODULE_1__.join)(__dirname, '..', 'index-react.html'));\n    // Hide menu bar\n    mainWindow.setMenu(null);\n    // Open DevTools in development\n    if (process.argv.includes('--dev')) {\n        mainWindow.webContents.openDevTools();\n    }\n    // Handle window close\n    mainWindow.on('close', (event) => {\n        if (!isQuitting && config.showInSystemTray) {\n            event.preventDefault();\n            mainWindow?.hide();\n        }\n    });\n    mainWindow.on('closed', () => {\n        mainWindow = null;\n    });\n}\nfunction createTray() {\n    if (!config.showInSystemTray)\n        return;\n    const iconPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(__dirname, '..', 'assets', 'icon.png');\n    const trayIcon = electron__WEBPACK_IMPORTED_MODULE_0__.nativeImage.createFromPath(iconPath).resize({ width: 16, height: 16 });\n    tray = new electron__WEBPACK_IMPORTED_MODULE_0__.Tray(trayIcon);\n    tray.setToolTip('ONE Filer Control');\n    updateTrayMenu();\n    tray.on('click', () => {\n        if (mainWindow) {\n            if (mainWindow.isVisible()) {\n                mainWindow.hide();\n            }\n            else {\n                mainWindow.show();\n                mainWindow.focus();\n            }\n        }\n        else {\n            createWindow();\n        }\n    });\n}\nfunction updateTrayMenu() {\n    if (!tray)\n        return;\n    const contextMenu = electron__WEBPACK_IMPORTED_MODULE_0__.Menu.buildFromTemplate([\n        {\n            label: 'Show/Hide',\n            click: () => {\n                if (mainWindow) {\n                    if (mainWindow.isVisible()) {\n                        mainWindow.hide();\n                    }\n                    else {\n                        mainWindow.show();\n                        mainWindow.focus();\n                    }\n                }\n                else {\n                    createWindow();\n                }\n            }\n        },\n        {\n            label: replicantProcess ? 'Stop Replicant' : 'Start Replicant',\n            click: async () => {\n                if (replicantProcess) {\n                    await stopReplicant();\n                }\n                else {\n                    // Need to get credentials from user\n                    if (mainWindow) {\n                        mainWindow.show();\n                        mainWindow.focus();\n                    }\n                    else {\n                        createWindow();\n                    }\n                }\n                updateTrayMenu();\n            }\n        },\n        { type: 'separator' },\n        {\n            label: 'Check for Updates',\n            click: async () => {\n                await checkForUpdates();\n            }\n        },\n        { type: 'separator' },\n        {\n            label: 'Quit',\n            click: () => {\n                isQuitting = true;\n                electron__WEBPACK_IMPORTED_MODULE_0__.app.quit();\n            }\n        }\n    ]);\n    tray.setContextMenu(contextMenu);\n}\n// Handle single instance\nif (!gotTheLock) {\n    // Another instance is already running\n    console.log('Another instance of ONE Filer is already running');\n    // Try to notify the existing instance\n    const client = net__WEBPACK_IMPORTED_MODULE_6__.createConnection({ port: IPC_PORT }, () => {\n        client.write(JSON.stringify({ command: 'show' }));\n        client.end();\n    });\n    client.on('error', () => {\n        // Couldn't connect to existing instance\n        console.error('Could not communicate with existing instance');\n    });\n    electron__WEBPACK_IMPORTED_MODULE_0__.app.quit();\n}\nelse {\n    // This is the primary instance\n    electron__WEBPACK_IMPORTED_MODULE_0__.app.on('second-instance', (event, commandLine, workingDirectory) => {\n        // Someone tried to run a second instance, we should focus our window instead\n        if (mainWindow) {\n            if (mainWindow.isMinimized())\n                mainWindow.restore();\n            if (!mainWindow.isVisible())\n                mainWindow.show();\n            mainWindow.focus();\n        }\n        else {\n            createWindow();\n        }\n    });\n    // Start IPC server for inter-process communication\n    ipcServer = net__WEBPACK_IMPORTED_MODULE_6__.createServer((socket) => {\n        socket.on('data', (data) => {\n            try {\n                const message = JSON.parse(data.toString());\n                if (message.command === 'show') {\n                    if (mainWindow) {\n                        if (mainWindow.isMinimized())\n                            mainWindow.restore();\n                        if (!mainWindow.isVisible())\n                            mainWindow.show();\n                        mainWindow.focus();\n                    }\n                    else {\n                        createWindow();\n                    }\n                }\n            }\n            catch (error) {\n                console.error('IPC message error:', error);\n            }\n        });\n    });\n    ipcServer.listen(IPC_PORT, '127.0.0.1', () => {\n        console.log(`IPC server listening on port ${IPC_PORT}`);\n    });\n    ipcServer.on('error', (err) => {\n        console.error('IPC server error:', err);\n    });\n}\n// Initialize ServiceManager early to ensure availability for IPC handlers\nif (gotTheLock) {\n    initializeServiceManager();\n}\n// Set app name for notifications\nelectron__WEBPACK_IMPORTED_MODULE_0__.app.setAppUserModelId('com.onefiler.login');\n// Set proper paths for app data to avoid permission issues\nconst userDataPath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(electron__WEBPACK_IMPORTED_MODULE_0__.app.getPath('userData'), 'ONE-Filer');\nelectron__WEBPACK_IMPORTED_MODULE_0__.app.setPath('userData', userDataPath);\nelectron__WEBPACK_IMPORTED_MODULE_0__.app.setPath('cache', (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(userDataPath, 'Cache'));\n// Ensure directories exist with proper permissions\ntry {\n    const { mkdirSync } = __webpack_require__(/*! fs */ \"fs\");\n    mkdirSync(userDataPath, { recursive: true });\n    mkdirSync((0,path__WEBPACK_IMPORTED_MODULE_1__.join)(userDataPath, 'Cache'), { recursive: true });\n}\ncatch (error) {\n    console.error('Failed to create app directories:', error);\n}\n// Initialize ServiceManager\nfunction initializeServiceManager() {\n    serviceManager = new _services_ServiceManager__WEBPACK_IMPORTED_MODULE_7__.ServiceManager();\n    // Register WSL service\n    serviceManager.registerService({\n        name: 'wsl',\n        checkCommand: 'wsl --list --running',\n        startCommand: 'wsl -e echo \"WSL started\"',\n        healthCheck: async () => {\n            try {\n                const { stdout } = await exec('wsl --list --running');\n                return stdout.includes(config.wslDistro || 'Ubuntu');\n            }\n            catch {\n                return false;\n            }\n        },\n        retryAttempts: 3,\n        retryDelay: 2000\n    });\n    // Register Replicant service\n    serviceManager.registerService({\n        name: 'replicant',\n        checkCommand: `wsl -d ${config.wslDistro || 'Ubuntu'} -e bash -c \"pgrep -f 'node.*one-filer.*start' || echo ''\"`,\n        startCommand: 'wsl -d {{distro}} -e bash -c \"{{command}}\"',\n        stopCommand: `wsl -d ${config.wslDistro || 'Ubuntu'} -e bash -c \"pkill -f 'node.*one-filer.*start' || true\"`,\n        requiredServices: ['wsl'],\n        healthCheck: async () => {\n            try {\n                const status = await serviceManager.checkService('replicant');\n                return status.status === 'running' && !!status.pid;\n            }\n            catch {\n                return false;\n            }\n        },\n        retryAttempts: 3,\n        retryDelay: 3000\n    });\n    // Set up event listeners\n    serviceManager.on('service-status-changed', (status) => {\n        console.log(`Service ${status.name} status changed to ${status.status}`);\n        if (mainWindow) {\n            mainWindow.webContents.send('service-status-update', status);\n        }\n    });\n    serviceManager.on('service-output', ({ service, data }) => {\n        console.log(`[${service}] ${data}`);\n        if (service === 'replicant') {\n            parseReplicantOutput(data);\n        }\n    });\n    serviceManager.on('service-error', ({ service, data }) => {\n        console.error(`[${service}] ERROR: ${data}`);\n    });\n    serviceManager.on('service-retry', ({ service, attempt, maxAttempts }) => {\n        console.log(`Retrying ${service} (${attempt}/${maxAttempts})...`);\n    });\n    serviceManager.on('service-failed', (status) => {\n        console.error(`Service ${status.name} failed to start: ${status.error}`);\n        if (mainWindow) {\n            mainWindow.webContents.send('service-error', {\n                service: status.name,\n                error: status.error\n            });\n        }\n    });\n}\nelectron__WEBPACK_IMPORTED_MODULE_0__.app.whenReady().then(() => {\n    if (gotTheLock) {\n        // ServiceManager already initialized earlier\n        createTray();\n        if (!config.startMinimized) {\n            createWindow();\n        }\n        electron__WEBPACK_IMPORTED_MODULE_0__.app.on('activate', () => {\n            if (electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow.getAllWindows().length === 0) {\n                createWindow();\n            }\n        });\n    }\n});\nelectron__WEBPACK_IMPORTED_MODULE_0__.app.on('window-all-closed', () => {\n    if (process.platform !== 'darwin' && !config.showInSystemTray) {\n        electron__WEBPACK_IMPORTED_MODULE_0__.app.quit();\n    }\n});\nelectron__WEBPACK_IMPORTED_MODULE_0__.app.on('before-quit', () => {\n    isQuitting = true;\n    // Clean up IPC server\n    if (ipcServer) {\n        ipcServer.close();\n        ipcServer = null;\n    }\n});\n// Handle login request\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('login', async (event, loginData) => {\n    try {\n        // Store credentials\n        credentials = { ...loginData };\n        // Check WSL using ServiceManager\n        const wslStatus = await serviceManager.checkService('wsl');\n        if (wslStatus.status !== 'running') {\n            console.log('WSL not running, attempting to start...');\n            try {\n                await serviceManager.startService('wsl');\n            }\n            catch (error) {\n                return {\n                    success: false,\n                    message: `Failed to start WSL: ${error instanceof Error ? error.message : 'Unknown error'}`\n                };\n            }\n        }\n        // Prepare replicant command\n        const replicantPath = config.replicantPath || '/mnt/c/Users/juerg/source/one.filer';\n        const configArg = loginData.configPath ?\n            `--config \"${loginData.configPath}\"` :\n            `--config \"${replicantPath}/configs/demo-config.json\"`;\n        const command = `cd ${replicantPath} && node lib/index.js start --secret \"${loginData.secret}\" --filer true ${configArg}`;\n        // Start replicant using ServiceManager\n        try {\n            const result = await serviceManager.startService('replicant', {\n                distro: config.wslDistro || 'Ubuntu',\n                command: command\n            });\n            if (result.status === 'running') {\n                replicantStartTime = new Date();\n                replicantProcess = serviceManager.processes.get('replicant') || null;\n                return {\n                    success: true,\n                    message: 'Successfully started ONE Filer replicant',\n                    mountPoint: 'Check WSL for mount location'\n                };\n            }\n            else {\n                return {\n                    success: false,\n                    message: result.error || 'Failed to start replicant'\n                };\n            }\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            console.error('Failed to start replicant:', errorMessage);\n            // Provide specific error messages\n            if (errorMessage.includes('Invalid password')) {\n                return {\n                    success: false,\n                    message: 'Invalid password. Please check your secret.'\n                };\n            }\n            else if (errorMessage.includes('Permission denied')) {\n                return {\n                    success: false,\n                    message: 'Permission denied. Please check file permissions.'\n                };\n            }\n            else if (errorMessage.includes('not found')) {\n                return {\n                    success: false,\n                    message: 'ONE Filer installation not found. Please check the installation path.'\n                };\n            }\n            return {\n                success: false,\n                message: errorMessage\n            };\n        }\n    }\n    catch (error) {\n        console.error('Login error:', error);\n        return {\n            success: false,\n            message: error instanceof Error ? error.message : 'Unknown error occurred'\n        };\n    }\n});\n// Start replicant in WSL\nasync function startReplicantInWSL(secret, configPath) {\n    try {\n        // Kill any existing replicant process\n        if (replicantProcess) {\n            console.log('Killing existing replicant process...');\n            replicantProcess.kill();\n            replicantProcess = null;\n        }\n        // Also kill any orphaned processes in WSL\n        try {\n            await exec(`wsl -d ${config.wslDistro || 'Ubuntu'} -e bash -c \"pkill -f 'node.*one-filer.*start' || true\"`);\n        }\n        catch {\n            // Ignore errors - process might not exist\n        }\n        // Build the command to run the replicant in WSL\n        // Use the local installation path instead of global command\n        const replicantPath = '/mnt/c/Users/juerg/source/one.filer';\n        // Use demo config if no config specified\n        const configArg = configPath ? `--config \"${configPath}\"` : `--config \"${replicantPath}/configs/demo-config.json\"`;\n        const command = `cd ${replicantPath} && node lib/index.js start --secret \"${secret}\" --filer true ${configArg}`;\n        // Start the replicant process in WSL\n        const wslDistro = config.wslDistro || 'Ubuntu';\n        console.log(`Starting replicant with command: ${command}`);\n        console.log(`Using WSL distro: ${wslDistro}`);\n        replicantProcess = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.spawn)('wsl', ['-d', wslDistro, '-e', 'bash', '-c', command], {\n            detached: false,\n            stdio: ['ignore', 'pipe', 'pipe']\n        });\n        return new Promise((resolve) => {\n            let output = '';\n            let errorOutput = '';\n            let resolved = false;\n            // Timeout after 10 seconds\n            const timeout = setTimeout(() => {\n                if (!resolved) {\n                    resolved = true;\n                    if (replicantProcess) {\n                        replicantProcess.kill();\n                        replicantProcess = null;\n                    }\n                    resolve({\n                        success: false,\n                        message: 'Timeout: Replicant failed to start within 10 seconds'\n                    });\n                }\n            }, 10000);\n            if (replicantProcess && replicantProcess.stdout) {\n                replicantProcess.stdout.on('data', (data) => {\n                    const dataStr = data.toString();\n                    output += dataStr;\n                    console.log('Replicant output:', dataStr);\n                    // Parse metrics from output\n                    parseReplicantOutput(dataStr);\n                    // Check if replicant started successfully\n                    if ((output.includes('[info]: Replicant started successfully') ||\n                        output.includes('âœ… Loaded FUSE3 N-API addon') ||\n                        output.includes('WSL2 Windows Filer started successfully')) && !resolved) {\n                        resolved = true;\n                        clearTimeout(timeout);\n                        // Try to extract mount point from output\n                        const mountMatch = output.match(/mount.*?([A-Z]:\\\\[^\\s]+|\\/[^\\s]+)/i);\n                        const mountPoint = mountMatch ? mountMatch[1] : undefined;\n                        // Update tray menu to reflect running state\n                        updateTrayMenu();\n                        replicantStartTime = new Date();\n                        resolve({\n                            success: true,\n                            message: 'Replicant started successfully',\n                            mountPoint\n                        });\n                    }\n                });\n            }\n            if (replicantProcess && replicantProcess.stderr) {\n                replicantProcess.stderr.on('data', (data) => {\n                    errorOutput += data.toString();\n                    console.error('Replicant error:', data.toString());\n                    // Check for specific errors\n                    if ((errorOutput.includes('Error: invalid password') ||\n                        errorOutput.includes('CYENC-SYMDEC')) && !resolved) {\n                        resolved = true;\n                        clearTimeout(timeout);\n                        if (replicantProcess) {\n                            replicantProcess.kill();\n                            replicantProcess = null;\n                        }\n                        resolve({\n                            success: false,\n                            message: 'Invalid password. Please check your secret.'\n                        });\n                    }\n                });\n            }\n            if (replicantProcess) {\n                replicantProcess.on('exit', (code) => {\n                    if (!resolved) {\n                        resolved = true;\n                        clearTimeout(timeout);\n                        replicantProcess = null;\n                        resolve({\n                            success: false,\n                            message: `Replicant process exited with code ${code}`\n                        });\n                    }\n                });\n                replicantProcess.on('error', (err) => {\n                    if (!resolved) {\n                        resolved = true;\n                        clearTimeout(timeout);\n                        replicantProcess = null;\n                        resolve({\n                            success: false,\n                            message: `Failed to start replicant: ${err.message}`\n                        });\n                    }\n                });\n            }\n        });\n    }\n    catch (error) {\n        console.error('Error starting replicant:', error);\n        return {\n            success: false,\n            message: error instanceof Error ? error.message : 'Failed to start replicant'\n        };\n    }\n}\n// Handle logout\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('logout', async () => {\n    try {\n        // Stop the replicant process\n        if (replicantProcess) {\n            replicantProcess.kill();\n            replicantProcess = null;\n        }\n        credentials = null;\n        return { success: true };\n    }\n    catch (error) {\n        console.error('Logout error:', error);\n        return {\n            success: false,\n            message: error instanceof Error ? error.message : 'Logout failed'\n        };\n    }\n});\n// Check WSL status\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('check-wsl-status', async () => {\n    try {\n        const wslStatus = await serviceManager.checkService('wsl');\n        // Get list of distros\n        const { stdout } = await exec('wsl --list --verbose');\n        const lines = stdout.split('\\n').filter(line => line.trim());\n        const distros = [];\n        // Parse WSL output\n        for (let i = 1; i < lines.length; i++) {\n            const line = lines[i].trim();\n            if (line) {\n                const parts = line.split(/\\s+/);\n                if (parts.length >= 2) {\n                    distros.push(parts[0].replace('*', '').trim());\n                }\n            }\n        }\n        return {\n            installed: distros.length > 0,\n            running: wslStatus.status === 'running',\n            distros\n        };\n    }\n    catch (error) {\n        // WSL not installed\n        return {\n            installed: false,\n            running: false,\n            distros: []\n        };\n    }\n});\n// Check replicant status\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('check-replicant-status', async () => {\n    try {\n        const status = await serviceManager.checkService('replicant');\n        return {\n            running: status.status === 'running',\n            pid: status.pid\n        };\n    }\n    catch (error) {\n        console.error('Error checking replicant status:', error);\n        return {\n            running: false\n        };\n    }\n});\n// Start WSL if not running\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('start-wsl', async () => {\n    try {\n        // Start default WSL distro\n        await exec('wsl -e echo \"WSL started\"');\n        return { success: true };\n    }\n    catch (error) {\n        return {\n            success: false,\n            message: error instanceof Error ? error.message : 'Failed to start WSL'\n        };\n    }\n});\n// Stop replicant process\nasync function stopReplicant() {\n    try {\n        await serviceManager.stopService('replicant');\n        replicantProcess = null;\n        replicantStartTime = null;\n        // Update tray menu\n        updateTrayMenu();\n        return { success: true };\n    }\n    catch (error) {\n        return {\n            success: false,\n            message: error instanceof Error ? error.message : 'Failed to stop replicant'\n        };\n    }\n}\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('stop-replicant', stopReplicant);\n// Run service diagnostics\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('run-diagnostics', async () => {\n    try {\n        const diagnostics = await serviceManager.runDiagnostics();\n        // Add additional system diagnostics\n        const systemDiagnostics = {\n            ...diagnostics,\n            system: {\n                platform: process.platform,\n                arch: process.arch,\n                nodeVersion: process.version,\n                electronVersion: process.versions.electron,\n                chromeVersion: process.versions.chrome,\n                v8Version: process.versions.v8\n            },\n            config: {\n                wslDistro: config.wslDistro,\n                replicantPath: config.replicantPath,\n                startMinimized: config.startMinimized,\n                showInSystemTray: config.showInSystemTray,\n                autoConnect: config.autoConnect\n            },\n            paths: {\n                userData: electron__WEBPACK_IMPORTED_MODULE_0__.app.getPath('userData'),\n                cache: (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(userDataPath, 'Cache'),\n                logs: electron__WEBPACK_IMPORTED_MODULE_0__.app.getPath('logs'),\n                temp: electron__WEBPACK_IMPORTED_MODULE_0__.app.getPath('temp')\n            }\n        };\n        return systemDiagnostics;\n    }\n    catch (error) {\n        console.error('Diagnostics error:', error);\n        throw error;\n    }\n});\n// Check for updates\nasync function checkForUpdates() {\n    try {\n        // Simple update check - in production, this would check GitHub releases or similar\n        const result = await electron__WEBPACK_IMPORTED_MODULE_0__.dialog.showMessageBox(mainWindow || new electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow({ show: false }), {\n            type: 'info',\n            title: 'Check for Updates',\n            message: 'Update check not implemented yet.',\n            detail: 'In production, this would check for new versions of ONE Filer.',\n            buttons: ['OK']\n        });\n    }\n    catch (error) {\n        console.error('Update check failed:', error);\n    }\n}\n// Parse replicant output to extract metrics\nfunction parseReplicantOutput(output) {\n    try {\n        // Parse connection count\n        const connectionMatch = output.match(/connections?:\\s*(\\d+)/i);\n        if (connectionMatch) {\n            metricsCache.connections = parseInt(connectionMatch[1]);\n        }\n        // Parse object counts\n        const objectsStoredMatch = output.match(/objects?\\s+stored:\\s*(\\d+)/i);\n        if (objectsStoredMatch) {\n            metricsCache.objectsStored = parseInt(objectsStoredMatch[1]);\n        }\n        const objectsSyncedMatch = output.match(/objects?\\s+synced:\\s*(\\d+)/i);\n        if (objectsSyncedMatch) {\n            metricsCache.objectsSynced = parseInt(objectsSyncedMatch[1]);\n        }\n        const syncQueueMatch = output.match(/sync\\s+queue:\\s*(\\d+)/i);\n        if (syncQueueMatch) {\n            metricsCache.syncQueue = parseInt(syncQueueMatch[1]);\n        }\n        // Parse bandwidth metrics\n        const uploadMatch = output.match(/upload:\\s*([\\d.]+)\\s*(KB|MB|GB)/i);\n        if (uploadMatch) {\n            const value = parseFloat(uploadMatch[1]);\n            const unit = uploadMatch[2].toUpperCase();\n            metricsCache.bandwidth.upload = unit === 'KB' ? value * 1024 :\n                unit === 'MB' ? value * 1024 * 1024 :\n                    value * 1024 * 1024 * 1024;\n        }\n        const downloadMatch = output.match(/download:\\s*([\\d.]+)\\s*(KB|MB|GB)/i);\n        if (downloadMatch) {\n            const value = parseFloat(downloadMatch[1]);\n            const unit = downloadMatch[2].toUpperCase();\n            metricsCache.bandwidth.download = unit === 'KB' ? value * 1024 :\n                unit === 'MB' ? value * 1024 * 1024 :\n                    value * 1024 * 1024 * 1024;\n        }\n        // Parse operation counts\n        const readsMatch = output.match(/reads?:\\s*(\\d+)/i);\n        if (readsMatch) {\n            metricsCache.operations.reads = parseInt(readsMatch[1]);\n        }\n        const writesMatch = output.match(/writes?:\\s*(\\d+)/i);\n        if (writesMatch) {\n            metricsCache.operations.writes = parseInt(writesMatch[1]);\n        }\n        const deletesMatch = output.match(/deletes?:\\s*(\\d+)/i);\n        if (deletesMatch) {\n            metricsCache.operations.deletes = parseInt(deletesMatch[1]);\n        }\n        // Parse performance metrics\n        const responseTimeMatch = output.match(/avg.*response.*time:\\s*([\\d.]+)\\s*ms/i);\n        if (responseTimeMatch) {\n            metricsCache.performance.avgResponseTime = parseFloat(responseTimeMatch[1]);\n        }\n        const rpsMatch = output.match(/requests?\\s*per\\s*second:\\s*([\\d.]+)/i);\n        if (rpsMatch) {\n            metricsCache.performance.requestsPerSecond = parseFloat(rpsMatch[1]);\n        }\n        // Parse errors\n        const errorsMatch = output.match(/errors?:\\s*(\\d+)/i);\n        if (errorsMatch) {\n            metricsCache.errors = parseInt(errorsMatch[1]);\n        }\n        // Update last sync time if we see sync activity\n        if (output.includes('sync completed') || output.includes('synced successfully')) {\n            metricsCache.lastSync = new Date();\n        }\n    }\n    catch (error) {\n        console.error('Error parsing replicant output:', error);\n    }\n}\n// Get system metrics\nelectron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.handle('get-system-metrics', async () => {\n    try {\n        // Get system metrics\n        const cpus = os__WEBPACK_IMPORTED_MODULE_5__.cpus();\n        const totalMemory = os__WEBPACK_IMPORTED_MODULE_5__.totalmem();\n        const freeMemory = os__WEBPACK_IMPORTED_MODULE_5__.freemem();\n        const usedMemory = totalMemory - freeMemory;\n        // Calculate CPU usage\n        let totalIdle = 0;\n        let totalTick = 0;\n        cpus.forEach(cpu => {\n            for (const type in cpu.times) {\n                totalTick += cpu.times[type];\n            }\n            totalIdle += cpu.times.idle;\n        });\n        const cpuUsage = 100 - ~~(100 * totalIdle / totalTick);\n        // Get disk usage (Windows specific)\n        let diskUsage = { used: 0, total: 0, percentage: 0 };\n        try {\n            const { stdout } = await exec('wmic logicaldisk get size,freespace,caption');\n            const lines = stdout.split('\\n').filter(line => line.trim());\n            for (let i = 1; i < lines.length; i++) {\n                const parts = lines[i].trim().split(/\\s+/);\n                if (parts.length >= 3 && parts[0] === 'C:') {\n                    const free = parseInt(parts[1]);\n                    const size = parseInt(parts[2]);\n                    if (!isNaN(free) && !isNaN(size)) {\n                        diskUsage = {\n                            total: size,\n                            used: size - free,\n                            percentage: Math.round(((size - free) / size) * 100)\n                        };\n                    }\n                }\n            }\n        }\n        catch (error) {\n            console.error('Failed to get disk usage:', error);\n        }\n        // Get network stats (simplified)\n        const networkStats = { bytesIn: 0, bytesOut: 0 };\n        // Get replicant metrics\n        const replicantStatus = replicantProcess && !replicantProcess.killed ? 'running' : 'stopped';\n        const uptime = replicantStartTime ? Math.floor((Date.now() - replicantStartTime.getTime()) / 1000) : 0;\n        // Get WSL metrics\n        let wslMetrics = {\n            status: 'stopped',\n            distro: config.wslDistro || 'Ubuntu',\n            version: '12',\n            memory: 0,\n            processes: 0\n        };\n        try {\n            const { stdout: wslStatus } = await exec('wsl --list --running');\n            if (wslStatus.includes(config.wslDistro || 'Ubuntu')) {\n                wslMetrics.status = 'running';\n                // Get WSL memory usage\n                try {\n                    const { stdout: memInfo } = await exec(`wsl -d ${config.wslDistro || 'Ubuntu'} -e cat /proc/meminfo`);\n                    const totalMatch = memInfo.match(/MemTotal:\\s+(\\d+)/);\n                    const availMatch = memInfo.match(/MemAvailable:\\s+(\\d+)/);\n                    if (totalMatch && availMatch) {\n                        const total = parseInt(totalMatch[1]) * 1024;\n                        const avail = parseInt(availMatch[1]) * 1024;\n                        wslMetrics.memory = total - avail;\n                    }\n                }\n                catch (error) {\n                    // Ignore\n                }\n                // Get WSL process count\n                try {\n                    const { stdout: psCount } = await exec(`wsl -d ${config.wslDistro || 'Ubuntu'} -e bash -c \"ps aux | wc -l\"`);\n                    wslMetrics.processes = parseInt(psCount.trim()) - 1; // Subtract header line\n                }\n                catch (error) {\n                    // Ignore\n                }\n            }\n        }\n        catch (error) {\n            // Ignore\n        }\n        return {\n            system: {\n                cpu: cpuUsage,\n                memory: {\n                    used: usedMemory,\n                    total: totalMemory,\n                    percentage: Math.round((usedMemory / totalMemory) * 100)\n                },\n                disk: diskUsage,\n                network: networkStats\n            },\n            replicant: {\n                status: replicantStatus,\n                uptime,\n                connections: metricsCache.connections,\n                objectsStored: metricsCache.objectsStored,\n                objectsSynced: metricsCache.objectsSynced,\n                syncQueue: metricsCache.syncQueue,\n                errors: metricsCache.errors,\n                lastSync: metricsCache.lastSync,\n                bandwidth: metricsCache.bandwidth,\n                operations: metricsCache.operations,\n                performance: metricsCache.performance\n            },\n            wsl: wslMetrics\n        };\n    }\n    catch (error) {\n        console.error('Failed to get metrics:', error);\n        throw error;\n    }\n});\n\n\n//# sourceURL=webpack://one-filer-login/./src/main.ts?\n}");

/***/ }),

/***/ "./src/services/ServiceManager.ts":
/*!****************************************!*\
  !*** ./src/services/ServiceManager.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServiceManager: () => (/* binding */ ServiceManager),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nconst exec = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_0__.exec);\nclass ServiceManager extends events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    services = new Map();\n    processes = new Map();\n    configs = new Map();\n    constructor() {\n        super();\n    }\n    registerService(config) {\n        this.configs.set(config.name, config);\n        this.services.set(config.name, {\n            name: config.name,\n            status: 'stopped',\n            lastCheck: new Date()\n        });\n    }\n    async checkService(name) {\n        const config = this.configs.get(name);\n        if (!config) {\n            throw new Error(`Service ${name} not registered`);\n        }\n        const status = this.services.get(name);\n        try {\n            // Run the check command\n            const { stdout, stderr } = await exec(config.checkCommand);\n            // If check command succeeds, service is running\n            status.status = 'running';\n            status.output = stdout;\n            status.error = undefined;\n            // Extract PID if possible\n            const pidMatch = stdout.match(/\\b(\\d+)\\b/);\n            if (pidMatch) {\n                status.pid = parseInt(pidMatch[1]);\n            }\n            // Run custom health check if provided\n            if (config.healthCheck) {\n                const isHealthy = await config.healthCheck();\n                if (!isHealthy) {\n                    status.status = 'error';\n                    status.error = 'Health check failed';\n                }\n            }\n        }\n        catch (error) {\n            status.status = 'stopped';\n            status.error = error instanceof Error ? error.message : 'Unknown error';\n            status.pid = undefined;\n        }\n        status.lastCheck = new Date();\n        this.emit('service-status-changed', status);\n        return status;\n    }\n    async startService(name, params) {\n        const config = this.configs.get(name);\n        if (!config) {\n            throw new Error(`Service ${name} not registered`);\n        }\n        const status = this.services.get(name);\n        // Check if already running\n        await this.checkService(name);\n        if (status.status === 'running') {\n            return status;\n        }\n        // Check required services\n        if (config.requiredServices) {\n            for (const reqService of config.requiredServices) {\n                const reqStatus = await this.checkService(reqService);\n                if (reqStatus.status !== 'running') {\n                    throw new Error(`Required service ${reqService} is not running`);\n                }\n            }\n        }\n        status.status = 'starting';\n        this.emit('service-status-changed', status);\n        let attempts = 0;\n        const maxAttempts = config.retryAttempts || 3;\n        const retryDelay = config.retryDelay || 2000;\n        while (attempts < maxAttempts) {\n            try {\n                attempts++;\n                // Parse and execute start command\n                let command = config.startCommand;\n                if (params) {\n                    for (const [key, value] of Object.entries(params)) {\n                        command = command.replace(`{{${key}}}`, value);\n                    }\n                }\n                const parts = command.split(' ');\n                const cmd = parts[0];\n                const args = parts.slice(1);\n                const process = (0,child_process__WEBPACK_IMPORTED_MODULE_0__.spawn)(cmd, args, {\n                    detached: false,\n                    stdio: ['ignore', 'pipe', 'pipe']\n                });\n                this.processes.set(name, process);\n                // Wait for service to start\n                const startupResult = await this.waitForStartup(name, process, config);\n                if (startupResult.success) {\n                    status.status = 'running';\n                    status.pid = process.pid;\n                    status.error = undefined;\n                    this.emit('service-started', status);\n                    return status;\n                }\n                else {\n                    throw new Error(startupResult.error || 'Service failed to start');\n                }\n            }\n            catch (error) {\n                status.error = error instanceof Error ? error.message : 'Unknown error';\n                if (attempts < maxAttempts) {\n                    this.emit('service-retry', { service: name, attempt: attempts, maxAttempts });\n                    await new Promise(resolve => setTimeout(resolve, retryDelay));\n                }\n                else {\n                    status.status = 'error';\n                    this.emit('service-failed', status);\n                    throw error;\n                }\n            }\n        }\n        return status;\n    }\n    async waitForStartup(name, process, config) {\n        return new Promise((resolve) => {\n            let output = '';\n            let errorOutput = '';\n            let resolved = false;\n            const timeout = setTimeout(() => {\n                if (!resolved) {\n                    resolved = true;\n                    process.kill();\n                    resolve({\n                        success: false,\n                        error: 'Service startup timeout'\n                    });\n                }\n            }, 30000); // 30 second timeout\n            if (process.stdout) {\n                process.stdout.on('data', (data) => {\n                    output += data.toString();\n                    this.emit('service-output', { service: name, data: data.toString() });\n                    // Check for success indicators\n                    if (this.checkStartupSuccess(name, output)) {\n                        if (!resolved) {\n                            resolved = true;\n                            clearTimeout(timeout);\n                            resolve({ success: true });\n                        }\n                    }\n                });\n            }\n            if (process.stderr) {\n                process.stderr.on('data', (data) => {\n                    errorOutput += data.toString();\n                    this.emit('service-error', { service: name, data: data.toString() });\n                    // Check for known errors\n                    const knownError = this.checkKnownErrors(name, errorOutput);\n                    if (knownError && !resolved) {\n                        resolved = true;\n                        clearTimeout(timeout);\n                        process.kill();\n                        resolve({ success: false, error: knownError });\n                    }\n                });\n            }\n            process.on('exit', (code) => {\n                if (!resolved) {\n                    resolved = true;\n                    clearTimeout(timeout);\n                    resolve({\n                        success: false,\n                        error: `Process exited with code ${code}`\n                    });\n                }\n            });\n            process.on('error', (err) => {\n                if (!resolved) {\n                    resolved = true;\n                    clearTimeout(timeout);\n                    resolve({\n                        success: false,\n                        error: err.message\n                    });\n                }\n            });\n        });\n    }\n    checkStartupSuccess(service, output) {\n        const successPatterns = {\n            'wsl': [\n                /WSL.*started/i,\n                /Linux.*ready/i\n            ],\n            'replicant': [\n                /Replicant started successfully/i,\n                /Loaded FUSE3 N-API addon/i,\n                /FUSE.*started successfully/i,\n                /mount.*successful/i\n            ]\n        };\n        const patterns = successPatterns[service] || [];\n        return patterns.some(pattern => pattern.test(output));\n    }\n    checkKnownErrors(service, output) {\n        const errorPatterns = {\n            'wsl': [\n                [/WSL.*not.*installed/i, 'WSL is not installed'],\n                [/no.*distro.*found/i, 'No WSL distribution found'],\n                [/access.*denied/i, 'Access denied to WSL']\n            ],\n            'replicant': [\n                [/invalid.*password/i, 'Invalid password'],\n                [/CYENC-SYMDEC/i, 'Decryption failed - invalid secret'],\n                [/module.*not.*found/i, 'Required module not found'],\n                [/permission.*denied/i, 'Permission denied'],\n                [/address.*in.*use/i, 'Port already in use']\n            ]\n        };\n        const patterns = errorPatterns[service] || [];\n        for (const [pattern, message] of patterns) {\n            if (pattern.test(output)) {\n                return message;\n            }\n        }\n        return null;\n    }\n    async stopService(name) {\n        const config = this.configs.get(name);\n        const process = this.processes.get(name);\n        const status = this.services.get(name);\n        if (!config || !status) {\n            throw new Error(`Service ${name} not registered`);\n        }\n        if (process) {\n            process.kill();\n            this.processes.delete(name);\n        }\n        if (config.stopCommand) {\n            try {\n                await exec(config.stopCommand);\n            }\n            catch (error) {\n                // Ignore stop command errors\n            }\n        }\n        status.status = 'stopped';\n        status.pid = undefined;\n        this.emit('service-stopped', status);\n    }\n    async runDiagnostics() {\n        const diagnostics = {\n            timestamp: new Date(),\n            services: {}\n        };\n        for (const [name, config] of this.configs) {\n            const status = await this.checkService(name);\n            diagnostics.services[name] = {\n                ...status,\n                config: {\n                    hasHealthCheck: !!config.healthCheck,\n                    hasRequiredServices: !!config.requiredServices,\n                    retryAttempts: config.retryAttempts || 3\n                }\n            };\n        }\n        return diagnostics;\n    }\n    getAllStatuses() {\n        return Array.from(this.services.values());\n    }\n    getStatus(name) {\n        return this.services.get(name);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ServiceManager);\n\n\n//# sourceURL=webpack://one-filer-login/./src/services/ServiceManager.ts?\n}");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;